import {
  ResizeObserver_es_default
} from "./chunk-U4764Y4W.js";
import {
  require_dayjs_min
} from "./chunk-DUZAQB23.js";
import {
  __awaiter,
  __rest
} from "./chunk-3FTN53LU.js";
import {
  isEqual_default
} from "./chunk-PO5LHHKV.js";
import {
  debounce_default,
  throttle_default
} from "./chunk-NVDFJZGF.js";
import {
  require_react
} from "./chunk-QSTP2CRO.js";
import {
  __commonJS,
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/.pnpm/js-cookie@2.2.1/node_modules/js-cookie/src/js.cookie.js
var require_js_cookie = __commonJS({
  "node_modules/.pnpm/js-cookie@2.2.1/node_modules/js-cookie/src/js.cookie.js"(exports, module) {
    (function(factory) {
      var registeredInModuleLoader;
      if (typeof define === "function" && define.amd) {
        define(factory);
        registeredInModuleLoader = true;
      }
      if (typeof exports === "object") {
        module.exports = factory();
        registeredInModuleLoader = true;
      }
      if (!registeredInModuleLoader) {
        var OldCookies = window.Cookies;
        var api = window.Cookies = factory();
        api.noConflict = function() {
          window.Cookies = OldCookies;
          return api;
        };
      }
    })(function() {
      function extend() {
        var i = 0;
        var result = {};
        for (; i < arguments.length; i++) {
          var attributes = arguments[i];
          for (var key in attributes) {
            result[key] = attributes[key];
          }
        }
        return result;
      }
      function decode(s) {
        return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
      }
      function init(converter) {
        function api() {
        }
        function set(key, value, attributes) {
          if (typeof document === "undefined") {
            return;
          }
          attributes = extend({
            path: "/"
          }, api.defaults, attributes);
          if (typeof attributes.expires === "number") {
            attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e5);
          }
          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : "";
          try {
            var result = JSON.stringify(value);
            if (/^[\{\[]/.test(result)) {
              value = result;
            }
          } catch (e) {
          }
          value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
          key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
          var stringifiedAttributes = "";
          for (var attributeName in attributes) {
            if (!attributes[attributeName]) {
              continue;
            }
            stringifiedAttributes += "; " + attributeName;
            if (attributes[attributeName] === true) {
              continue;
            }
            stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
          }
          return document.cookie = key + "=" + value + stringifiedAttributes;
        }
        function get(key, json) {
          if (typeof document === "undefined") {
            return;
          }
          var jar = {};
          var cookies = document.cookie ? document.cookie.split("; ") : [];
          var i = 0;
          for (; i < cookies.length; i++) {
            var parts = cookies[i].split("=");
            var cookie = parts.slice(1).join("=");
            if (!json && cookie.charAt(0) === '"') {
              cookie = cookie.slice(1, -1);
            }
            try {
              var name = decode(parts[0]);
              cookie = (converter.read || converter)(cookie, name) || decode(cookie);
              if (json) {
                try {
                  cookie = JSON.parse(cookie);
                } catch (e) {
                }
              }
              jar[name] = cookie;
              if (key === name) {
                break;
              }
            } catch (e) {
            }
          }
          return key ? jar[key] : jar;
        }
        api.set = set;
        api.get = function(key) {
          return get(
            key,
            false
            /* read as raw */
          );
        };
        api.getJSON = function(key) {
          return get(
            key,
            true
            /* read as json */
          );
        };
        api.remove = function(key, attributes) {
          set(key, "", extend(attributes, {
            expires: -1
          }));
        };
        api.defaults = {};
        api.withConverter = init;
        return api;
      }
      return init(function() {
      });
    });
  }
});

// node_modules/.pnpm/screenfull@5.2.0/node_modules/screenfull/dist/screenfull.js
var require_screenfull = __commonJS({
  "node_modules/.pnpm/screenfull@5.2.0/node_modules/screenfull/dist/screenfull.js"(exports, module) {
    (function() {
      "use strict";
      var document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
      var isCommonjs = typeof module !== "undefined" && module.exports;
      var fn = function() {
        var val;
        var fnMap = [
          [
            "requestFullscreen",
            "exitFullscreen",
            "fullscreenElement",
            "fullscreenEnabled",
            "fullscreenchange",
            "fullscreenerror"
          ],
          // New WebKit
          [
            "webkitRequestFullscreen",
            "webkitExitFullscreen",
            "webkitFullscreenElement",
            "webkitFullscreenEnabled",
            "webkitfullscreenchange",
            "webkitfullscreenerror"
          ],
          // Old WebKit
          [
            "webkitRequestFullScreen",
            "webkitCancelFullScreen",
            "webkitCurrentFullScreenElement",
            "webkitCancelFullScreen",
            "webkitfullscreenchange",
            "webkitfullscreenerror"
          ],
          [
            "mozRequestFullScreen",
            "mozCancelFullScreen",
            "mozFullScreenElement",
            "mozFullScreenEnabled",
            "mozfullscreenchange",
            "mozfullscreenerror"
          ],
          [
            "msRequestFullscreen",
            "msExitFullscreen",
            "msFullscreenElement",
            "msFullscreenEnabled",
            "MSFullscreenChange",
            "MSFullscreenError"
          ]
        ];
        var i = 0;
        var l = fnMap.length;
        var ret = {};
        for (; i < l; i++) {
          val = fnMap[i];
          if (val && val[1] in document2) {
            for (i = 0; i < val.length; i++) {
              ret[fnMap[0][i]] = val[i];
            }
            return ret;
          }
        }
        return false;
      }();
      var eventNameMap = {
        change: fn.fullscreenchange,
        error: fn.fullscreenerror
      };
      var screenfull2 = {
        request: function(element, options) {
          return new Promise(function(resolve, reject) {
            var onFullScreenEntered = function() {
              this.off("change", onFullScreenEntered);
              resolve();
            }.bind(this);
            this.on("change", onFullScreenEntered);
            element = element || document2.documentElement;
            var returnPromise = element[fn.requestFullscreen](options);
            if (returnPromise instanceof Promise) {
              returnPromise.then(onFullScreenEntered).catch(reject);
            }
          }.bind(this));
        },
        exit: function() {
          return new Promise(function(resolve, reject) {
            if (!this.isFullscreen) {
              resolve();
              return;
            }
            var onFullScreenExit = function() {
              this.off("change", onFullScreenExit);
              resolve();
            }.bind(this);
            this.on("change", onFullScreenExit);
            var returnPromise = document2[fn.exitFullscreen]();
            if (returnPromise instanceof Promise) {
              returnPromise.then(onFullScreenExit).catch(reject);
            }
          }.bind(this));
        },
        toggle: function(element, options) {
          return this.isFullscreen ? this.exit() : this.request(element, options);
        },
        onchange: function(callback) {
          this.on("change", callback);
        },
        onerror: function(callback) {
          this.on("error", callback);
        },
        on: function(event, callback) {
          var eventName = eventNameMap[event];
          if (eventName) {
            document2.addEventListener(eventName, callback, false);
          }
        },
        off: function(event, callback) {
          var eventName = eventNameMap[event];
          if (eventName) {
            document2.removeEventListener(eventName, callback, false);
          }
        },
        raw: fn
      };
      if (!fn) {
        if (isCommonjs) {
          module.exports = { isEnabled: false };
        } else {
          window.screenfull = { isEnabled: false };
        }
        return;
      }
      Object.defineProperties(screenfull2, {
        isFullscreen: {
          get: function() {
            return Boolean(document2[fn.fullscreenElement]);
          }
        },
        element: {
          enumerable: true,
          get: function() {
            return document2[fn.fullscreenElement];
          }
        },
        isEnabled: {
          enumerable: true,
          get: function() {
            return Boolean(document2[fn.fullscreenEnabled]);
          }
        }
      });
      if (isCommonjs) {
        module.exports = screenfull2;
      } else {
        window.screenfull = screenfull2;
      }
    })();
  }
});

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/createUpdateEffect/index.js
var import_react = __toESM(require_react());
var createUpdateEffect = (hook) => (effect, deps) => {
  const isMounted = (0, import_react.useRef)(false);
  hook(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);
  hook(() => {
    if (!isMounted.current) {
      isMounted.current = true;
    } else {
      return effect();
    }
  }, deps);
};

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useAntdTable/index.js
var import_react18 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useMemoizedFn/index.js
var import_react2 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/index.js
var isObject = (value) => value !== null && typeof value === "object";
var isFunction = (value) => typeof value === "function";
var isString = (value) => typeof value === "string";
var isNumber = (value) => typeof value === "number";
var isUndef = (value) => typeof value === "undefined";

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/isDev.js
var isDev = true;
var isDev_default = isDev;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useMemoizedFn/index.js
function useMemoizedFn(fn) {
  if (isDev_default) {
    if (!isFunction(fn)) {
      console.error(`useMemoizedFn expected parameter is a function, got ${typeof fn}`);
    }
  }
  const fnRef = (0, import_react2.useRef)(fn);
  fnRef.current = (0, import_react2.useMemo)(() => fn, [fn]);
  const memoizedFn = (0, import_react2.useRef)();
  if (!memoizedFn.current) {
    memoizedFn.current = function(...args) {
      return fnRef.current.apply(this, args);
    };
  }
  return memoizedFn.current;
}
var useMemoizedFn_default = useMemoizedFn;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/usePagination/index.js
var import_react17 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/useAutoRunPlugin.js
var import_react4 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useUpdateEffect/index.js
var import_react3 = __toESM(require_react());
var useUpdateEffect_default = createUpdateEffect(import_react3.useEffect);

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/useAutoRunPlugin.js
var useAutoRunPlugin = (fetchInstance, {
  manual,
  ready = true,
  defaultParams = [],
  refreshDeps = [],
  refreshDepsAction
}) => {
  const hasAutoRun = (0, import_react4.useRef)(false);
  hasAutoRun.current = false;
  useUpdateEffect_default(() => {
    if (!manual && ready) {
      hasAutoRun.current = true;
      fetchInstance.run(...defaultParams);
    }
  }, [ready]);
  useUpdateEffect_default(() => {
    if (hasAutoRun.current) {
      return;
    }
    if (!manual) {
      hasAutoRun.current = true;
      if (refreshDepsAction) {
        refreshDepsAction();
      } else {
        fetchInstance.refresh();
      }
    }
  }, [...refreshDeps]);
  return {
    onBefore: () => {
      if (!ready) {
        return {
          stopNow: true
        };
      }
    }
  };
};
useAutoRunPlugin.onInit = ({
  ready = true,
  manual
}) => {
  return {
    loading: !manual && ready
  };
};
var useAutoRunPlugin_default = useAutoRunPlugin;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/useCachePlugin.js
var import_react8 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useCreation/index.js
var import_react5 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/depsAreSame.js
function depsAreSame(oldDeps, deps) {
  if (oldDeps === deps)
    return true;
  for (let i = 0; i < oldDeps.length; i++) {
    if (!Object.is(oldDeps[i], deps[i]))
      return false;
  }
  return true;
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useCreation/index.js
function useCreation(factory, deps) {
  const {
    current
  } = (0, import_react5.useRef)({
    deps,
    obj: void 0,
    initialized: false
  });
  if (current.initialized === false || !depsAreSame(current.deps, deps)) {
    current.deps = deps;
    current.obj = factory();
    current.initialized = true;
  }
  return current.obj;
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useUnmount/index.js
var import_react7 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useLatest/index.js
var import_react6 = __toESM(require_react());
function useLatest(value) {
  const ref = (0, import_react6.useRef)(value);
  ref.current = value;
  return ref;
}
var useLatest_default = useLatest;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useUnmount/index.js
var useUnmount = (fn) => {
  if (isDev_default) {
    if (!isFunction(fn)) {
      console.error(`useUnmount expected parameter is a function, got ${typeof fn}`);
    }
  }
  const fnRef = useLatest_default(fn);
  (0, import_react7.useEffect)(() => () => {
    fnRef.current();
  }, []);
};
var useUnmount_default = useUnmount;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/utils/cache.js
var cache = /* @__PURE__ */ new Map();
var setCache = (key, cacheTime, cachedData) => {
  const currentCache = cache.get(key);
  if (currentCache === null || currentCache === void 0 ? void 0 : currentCache.timer) {
    clearTimeout(currentCache.timer);
  }
  let timer = void 0;
  if (cacheTime > -1) {
    timer = setTimeout(() => {
      cache.delete(key);
    }, cacheTime);
  }
  cache.set(key, Object.assign(Object.assign({}, cachedData), {
    timer
  }));
};
var getCache = (key) => {
  return cache.get(key);
};
var clearCache = (key) => {
  if (key) {
    const cacheKeys = Array.isArray(key) ? key : [key];
    cacheKeys.forEach((cacheKey) => cache.delete(cacheKey));
  } else {
    cache.clear();
  }
};

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/utils/cachePromise.js
var cachePromise = /* @__PURE__ */ new Map();
var getCachePromise = (cacheKey) => {
  return cachePromise.get(cacheKey);
};
var setCachePromise = (cacheKey, promise) => {
  cachePromise.set(cacheKey, promise);
  promise.then((res) => {
    cachePromise.delete(cacheKey);
    return res;
  }).catch(() => {
    cachePromise.delete(cacheKey);
  });
};

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/utils/cacheSubscribe.js
var listeners = {};
var trigger = (key, data) => {
  if (listeners[key]) {
    listeners[key].forEach((item) => item(data));
  }
};
var subscribe = (key, listener) => {
  if (!listeners[key]) {
    listeners[key] = [];
  }
  listeners[key].push(listener);
  return function unsubscribe() {
    const index = listeners[key].indexOf(listener);
    listeners[key].splice(index, 1);
  };
};

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/useCachePlugin.js
var useCachePlugin = (fetchInstance, {
  cacheKey,
  cacheTime = 5 * 60 * 1e3,
  staleTime = 0,
  setCache: customSetCache,
  getCache: customGetCache
}) => {
  const unSubscribeRef = (0, import_react8.useRef)();
  const currentPromiseRef = (0, import_react8.useRef)();
  const _setCache = (key, cachedData) => {
    if (customSetCache) {
      customSetCache(cachedData);
    } else {
      setCache(key, cacheTime, cachedData);
    }
    trigger(key, cachedData.data);
  };
  const _getCache = (key, params = []) => {
    if (customGetCache) {
      return customGetCache(params);
    }
    return getCache(key);
  };
  useCreation(() => {
    if (!cacheKey) {
      return;
    }
    const cacheData = _getCache(cacheKey);
    if (cacheData && Object.hasOwnProperty.call(cacheData, "data")) {
      fetchInstance.state.data = cacheData.data;
      fetchInstance.state.params = cacheData.params;
      if (staleTime === -1 || new Date().getTime() - cacheData.time <= staleTime) {
        fetchInstance.state.loading = false;
      }
    }
    unSubscribeRef.current = subscribe(cacheKey, (data) => {
      fetchInstance.setState({
        data
      });
    });
  }, []);
  useUnmount_default(() => {
    var _a;
    (_a = unSubscribeRef.current) === null || _a === void 0 ? void 0 : _a.call(unSubscribeRef);
  });
  if (!cacheKey) {
    return {};
  }
  return {
    onBefore: (params) => {
      const cacheData = _getCache(cacheKey, params);
      if (!cacheData || !Object.hasOwnProperty.call(cacheData, "data")) {
        return {};
      }
      if (staleTime === -1 || new Date().getTime() - cacheData.time <= staleTime) {
        return {
          loading: false,
          data: cacheData === null || cacheData === void 0 ? void 0 : cacheData.data,
          error: void 0,
          returnNow: true
        };
      } else {
        return {
          data: cacheData === null || cacheData === void 0 ? void 0 : cacheData.data,
          error: void 0
        };
      }
    },
    onRequest: (service, args) => {
      let servicePromise = getCachePromise(cacheKey);
      if (servicePromise && servicePromise !== currentPromiseRef.current) {
        return {
          servicePromise
        };
      }
      servicePromise = service(...args);
      currentPromiseRef.current = servicePromise;
      setCachePromise(cacheKey, servicePromise);
      return {
        servicePromise
      };
    },
    onSuccess: (data, params) => {
      var _a;
      if (cacheKey) {
        (_a = unSubscribeRef.current) === null || _a === void 0 ? void 0 : _a.call(unSubscribeRef);
        _setCache(cacheKey, {
          data,
          params,
          time: new Date().getTime()
        });
        unSubscribeRef.current = subscribe(cacheKey, (d) => {
          fetchInstance.setState({
            data: d
          });
        });
      }
    },
    onMutate: (data) => {
      var _a;
      if (cacheKey) {
        (_a = unSubscribeRef.current) === null || _a === void 0 ? void 0 : _a.call(unSubscribeRef);
        _setCache(cacheKey, {
          data,
          params: fetchInstance.state.params,
          time: new Date().getTime()
        });
        unSubscribeRef.current = subscribe(cacheKey, (d) => {
          fetchInstance.setState({
            data: d
          });
        });
      }
    }
  };
};
var useCachePlugin_default = useCachePlugin;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/useDebouncePlugin.js
var import_react9 = __toESM(require_react());
var useDebouncePlugin = (fetchInstance, {
  debounceWait,
  debounceLeading,
  debounceTrailing,
  debounceMaxWait
}) => {
  const debouncedRef = (0, import_react9.useRef)();
  const options = (0, import_react9.useMemo)(() => {
    const ret = {};
    if (debounceLeading !== void 0) {
      ret.leading = debounceLeading;
    }
    if (debounceTrailing !== void 0) {
      ret.trailing = debounceTrailing;
    }
    if (debounceMaxWait !== void 0) {
      ret.maxWait = debounceMaxWait;
    }
    return ret;
  }, [debounceLeading, debounceTrailing, debounceMaxWait]);
  (0, import_react9.useEffect)(() => {
    if (debounceWait) {
      const _originRunAsync = fetchInstance.runAsync.bind(fetchInstance);
      debouncedRef.current = debounce_default((callback) => {
        callback();
      }, debounceWait, options);
      fetchInstance.runAsync = (...args) => {
        return new Promise((resolve, reject) => {
          var _a;
          (_a = debouncedRef.current) === null || _a === void 0 ? void 0 : _a.call(debouncedRef, () => {
            _originRunAsync(...args).then(resolve).catch(reject);
          });
        });
      };
      return () => {
        var _a;
        (_a = debouncedRef.current) === null || _a === void 0 ? void 0 : _a.cancel();
        fetchInstance.runAsync = _originRunAsync;
      };
    }
  }, [debounceWait, options]);
  if (!debounceWait) {
    return {};
  }
  return {
    onCancel: () => {
      var _a;
      (_a = debouncedRef.current) === null || _a === void 0 ? void 0 : _a.cancel();
    }
  };
};
var useDebouncePlugin_default = useDebouncePlugin;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/useLoadingDelayPlugin.js
var import_react10 = __toESM(require_react());
var useLoadingDelayPlugin = (fetchInstance, {
  loadingDelay
}) => {
  const timerRef = (0, import_react10.useRef)();
  if (!loadingDelay) {
    return {};
  }
  const cancelTimeout = () => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
  };
  return {
    onBefore: () => {
      cancelTimeout();
      timerRef.current = setTimeout(() => {
        fetchInstance.setState({
          loading: true
        });
      }, loadingDelay);
      return {
        loading: false
      };
    },
    onFinally: () => {
      cancelTimeout();
    },
    onCancel: () => {
      cancelTimeout();
    }
  };
};
var useLoadingDelayPlugin_default = useLoadingDelayPlugin;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/usePollingPlugin.js
var import_react11 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/isBrowser.js
var isBrowser = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var isBrowser_default = isBrowser;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/utils/isDocumentVisible.js
function isDocumentVisible() {
  if (isBrowser_default) {
    return document.visibilityState !== "hidden";
  }
  return true;
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/utils/subscribeReVisible.js
var listeners2 = [];
function subscribe2(listener) {
  listeners2.push(listener);
  return function unsubscribe() {
    const index = listeners2.indexOf(listener);
    listeners2.splice(index, 1);
  };
}
if (isBrowser_default) {
  const revalidate = () => {
    if (!isDocumentVisible())
      return;
    for (let i = 0; i < listeners2.length; i++) {
      const listener = listeners2[i];
      listener();
    }
  };
  window.addEventListener("visibilitychange", revalidate, false);
}
var subscribeReVisible_default = subscribe2;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/usePollingPlugin.js
var usePollingPlugin = (fetchInstance, {
  pollingInterval,
  pollingWhenHidden = true,
  pollingErrorRetryCount = -1
}) => {
  const timerRef = (0, import_react11.useRef)();
  const unsubscribeRef = (0, import_react11.useRef)();
  const countRef = (0, import_react11.useRef)(0);
  const stopPolling = () => {
    var _a;
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
    (_a = unsubscribeRef.current) === null || _a === void 0 ? void 0 : _a.call(unsubscribeRef);
  };
  useUpdateEffect_default(() => {
    if (!pollingInterval) {
      stopPolling();
    }
  }, [pollingInterval]);
  if (!pollingInterval) {
    return {};
  }
  return {
    onBefore: () => {
      stopPolling();
    },
    onError: () => {
      countRef.current += 1;
    },
    onSuccess: () => {
      countRef.current = 0;
    },
    onFinally: () => {
      if (pollingErrorRetryCount === -1 || // When an error occurs, the request is not repeated after pollingErrorRetryCount retries
      pollingErrorRetryCount !== -1 && countRef.current <= pollingErrorRetryCount) {
        timerRef.current = setTimeout(() => {
          if (!pollingWhenHidden && !isDocumentVisible()) {
            unsubscribeRef.current = subscribeReVisible_default(() => {
              fetchInstance.refresh();
            });
          } else {
            fetchInstance.refresh();
          }
        }, pollingInterval);
      } else {
        countRef.current = 0;
      }
    },
    onCancel: () => {
      stopPolling();
    }
  };
};
var usePollingPlugin_default = usePollingPlugin;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/useRefreshOnWindowFocusPlugin.js
var import_react12 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/utils/limit.js
function limit(fn, timespan) {
  let pending = false;
  return (...args) => {
    if (pending)
      return;
    pending = true;
    fn(...args);
    setTimeout(() => {
      pending = false;
    }, timespan);
  };
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/utils/isOnline.js
function isOnline() {
  if (isBrowser_default && typeof navigator.onLine !== "undefined") {
    return navigator.onLine;
  }
  return true;
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/utils/subscribeFocus.js
var listeners3 = [];
function subscribe3(listener) {
  listeners3.push(listener);
  return function unsubscribe() {
    const index = listeners3.indexOf(listener);
    if (index > -1) {
      listeners3.splice(index, 1);
    }
  };
}
if (isBrowser_default) {
  const revalidate = () => {
    if (!isDocumentVisible() || !isOnline())
      return;
    for (let i = 0; i < listeners3.length; i++) {
      const listener = listeners3[i];
      listener();
    }
  };
  window.addEventListener("visibilitychange", revalidate, false);
  window.addEventListener("focus", revalidate, false);
}
var subscribeFocus_default = subscribe3;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/useRefreshOnWindowFocusPlugin.js
var useRefreshOnWindowFocusPlugin = (fetchInstance, {
  refreshOnWindowFocus,
  focusTimespan = 5e3
}) => {
  const unsubscribeRef = (0, import_react12.useRef)();
  const stopSubscribe = () => {
    var _a;
    (_a = unsubscribeRef.current) === null || _a === void 0 ? void 0 : _a.call(unsubscribeRef);
  };
  (0, import_react12.useEffect)(() => {
    if (refreshOnWindowFocus) {
      const limitRefresh = limit(fetchInstance.refresh.bind(fetchInstance), focusTimespan);
      unsubscribeRef.current = subscribeFocus_default(() => {
        limitRefresh();
      });
    }
    return () => {
      stopSubscribe();
    };
  }, [refreshOnWindowFocus, focusTimespan]);
  useUnmount_default(() => {
    stopSubscribe();
  });
  return {};
};
var useRefreshOnWindowFocusPlugin_default = useRefreshOnWindowFocusPlugin;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/useRetryPlugin.js
var import_react13 = __toESM(require_react());
var useRetryPlugin = (fetchInstance, {
  retryInterval,
  retryCount
}) => {
  const timerRef = (0, import_react13.useRef)();
  const countRef = (0, import_react13.useRef)(0);
  const triggerByRetry = (0, import_react13.useRef)(false);
  if (!retryCount) {
    return {};
  }
  return {
    onBefore: () => {
      if (!triggerByRetry.current) {
        countRef.current = 0;
      }
      triggerByRetry.current = false;
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    },
    onSuccess: () => {
      countRef.current = 0;
    },
    onError: () => {
      countRef.current += 1;
      if (retryCount === -1 || countRef.current <= retryCount) {
        const timeout = retryInterval !== null && retryInterval !== void 0 ? retryInterval : Math.min(1e3 * Math.pow(2, countRef.current), 3e4);
        timerRef.current = setTimeout(() => {
          triggerByRetry.current = true;
          fetchInstance.refresh();
        }, timeout);
      } else {
        countRef.current = 0;
      }
    },
    onCancel: () => {
      countRef.current = 0;
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    }
  };
};
var useRetryPlugin_default = useRetryPlugin;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/plugins/useThrottlePlugin.js
var import_react14 = __toESM(require_react());
var useThrottlePlugin = (fetchInstance, {
  throttleWait,
  throttleLeading,
  throttleTrailing
}) => {
  const throttledRef = (0, import_react14.useRef)();
  const options = {};
  if (throttleLeading !== void 0) {
    options.leading = throttleLeading;
  }
  if (throttleTrailing !== void 0) {
    options.trailing = throttleTrailing;
  }
  (0, import_react14.useEffect)(() => {
    if (throttleWait) {
      const _originRunAsync = fetchInstance.runAsync.bind(fetchInstance);
      throttledRef.current = throttle_default((callback) => {
        callback();
      }, throttleWait, options);
      fetchInstance.runAsync = (...args) => {
        return new Promise((resolve, reject) => {
          var _a;
          (_a = throttledRef.current) === null || _a === void 0 ? void 0 : _a.call(throttledRef, () => {
            _originRunAsync(...args).then(resolve).catch(reject);
          });
        });
      };
      return () => {
        var _a;
        fetchInstance.runAsync = _originRunAsync;
        (_a = throttledRef.current) === null || _a === void 0 ? void 0 : _a.cancel();
      };
    }
  }, [throttleWait, throttleLeading, throttleTrailing]);
  if (!throttleWait) {
    return {};
  }
  return {
    onCancel: () => {
      var _a;
      (_a = throttledRef.current) === null || _a === void 0 ? void 0 : _a.cancel();
    }
  };
};
var useThrottlePlugin_default = useThrottlePlugin;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useMount/index.js
var import_react15 = __toESM(require_react());
var useMount = (fn) => {
  if (isDev_default) {
    if (!isFunction(fn)) {
      console.error(`useMount: parameter \`fn\` expected to be a function, but got "${typeof fn}".`);
    }
  }
  (0, import_react15.useEffect)(() => {
    fn === null || fn === void 0 ? void 0 : fn();
  }, []);
};
var useMount_default = useMount;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useUpdate/index.js
var import_react16 = __toESM(require_react());
var useUpdate = () => {
  const [, setState] = (0, import_react16.useState)({});
  return (0, import_react16.useCallback)(() => setState({}), []);
};
var useUpdate_default = useUpdate;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/Fetch.js
var Fetch = class {
  constructor(serviceRef, options, subscribe4, initState3 = {}) {
    this.serviceRef = serviceRef;
    this.options = options;
    this.subscribe = subscribe4;
    this.initState = initState3;
    this.count = 0;
    this.state = {
      loading: false,
      params: void 0,
      data: void 0,
      error: void 0
    };
    this.state = Object.assign(Object.assign(Object.assign({}, this.state), {
      loading: !options.manual
    }), initState3);
  }
  setState(s = {}) {
    this.state = Object.assign(Object.assign({}, this.state), s);
    this.subscribe();
  }
  runPluginHandler(event, ...rest) {
    const r = this.pluginImpls.map((i) => {
      var _a;
      return (_a = i[event]) === null || _a === void 0 ? void 0 : _a.call(i, ...rest);
    }).filter(Boolean);
    return Object.assign({}, ...r);
  }
  runAsync(...params) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return __awaiter(this, void 0, void 0, function* () {
      this.count += 1;
      const currentCount = this.count;
      const _l = this.runPluginHandler("onBefore", params), {
        stopNow = false,
        returnNow = false
      } = _l, state = __rest(_l, ["stopNow", "returnNow"]);
      if (stopNow) {
        return new Promise(() => {
        });
      }
      this.setState(Object.assign({
        loading: true,
        params
      }, state));
      if (returnNow) {
        return Promise.resolve(state.data);
      }
      (_b = (_a = this.options).onBefore) === null || _b === void 0 ? void 0 : _b.call(_a, params);
      try {
        let {
          servicePromise
        } = this.runPluginHandler("onRequest", this.serviceRef.current, params);
        if (!servicePromise) {
          servicePromise = this.serviceRef.current(...params);
        }
        const res = yield servicePromise;
        if (currentCount !== this.count) {
          return new Promise(() => {
          });
        }
        this.setState({
          data: res,
          error: void 0,
          loading: false
        });
        (_d = (_c = this.options).onSuccess) === null || _d === void 0 ? void 0 : _d.call(_c, res, params);
        this.runPluginHandler("onSuccess", res, params);
        (_f = (_e = this.options).onFinally) === null || _f === void 0 ? void 0 : _f.call(_e, params, res, void 0);
        if (currentCount === this.count) {
          this.runPluginHandler("onFinally", params, res, void 0);
        }
        return res;
      } catch (error) {
        if (currentCount !== this.count) {
          return new Promise(() => {
          });
        }
        this.setState({
          error,
          loading: false
        });
        (_h = (_g = this.options).onError) === null || _h === void 0 ? void 0 : _h.call(_g, error, params);
        this.runPluginHandler("onError", error, params);
        (_k = (_j = this.options).onFinally) === null || _k === void 0 ? void 0 : _k.call(_j, params, void 0, error);
        if (currentCount === this.count) {
          this.runPluginHandler("onFinally", params, void 0, error);
        }
        throw error;
      }
    });
  }
  run(...params) {
    this.runAsync(...params).catch((error) => {
      if (!this.options.onError) {
        console.error(error);
      }
    });
  }
  cancel() {
    this.count += 1;
    this.setState({
      loading: false
    });
    this.runPluginHandler("onCancel");
  }
  refresh() {
    this.run(...this.state.params || []);
  }
  refreshAsync() {
    return this.runAsync(...this.state.params || []);
  }
  mutate(data) {
    const targetData = isFunction(data) ? data(this.state.data) : data;
    this.runPluginHandler("onMutate", targetData);
    this.setState({
      data: targetData
    });
  }
};

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/useRequestImplement.js
function useRequestImplement(service, options = {}, plugins = []) {
  const {
    manual = false
  } = options, rest = __rest(options, ["manual"]);
  const fetchOptions = Object.assign({
    manual
  }, rest);
  const serviceRef = useLatest_default(service);
  const update = useUpdate_default();
  const fetchInstance = useCreation(() => {
    const initState3 = plugins.map((p) => {
      var _a;
      return (_a = p === null || p === void 0 ? void 0 : p.onInit) === null || _a === void 0 ? void 0 : _a.call(p, fetchOptions);
    }).filter(Boolean);
    return new Fetch(serviceRef, fetchOptions, update, Object.assign({}, ...initState3));
  }, []);
  fetchInstance.options = fetchOptions;
  fetchInstance.pluginImpls = plugins.map((p) => p(fetchInstance, fetchOptions));
  useMount_default(() => {
    if (!manual) {
      const params = fetchInstance.state.params || options.defaultParams || [];
      fetchInstance.run(...params);
    }
  });
  useUnmount_default(() => {
    fetchInstance.cancel();
  });
  return {
    loading: fetchInstance.state.loading,
    data: fetchInstance.state.data,
    error: fetchInstance.state.error,
    params: fetchInstance.state.params || [],
    cancel: useMemoizedFn_default(fetchInstance.cancel.bind(fetchInstance)),
    refresh: useMemoizedFn_default(fetchInstance.refresh.bind(fetchInstance)),
    refreshAsync: useMemoizedFn_default(fetchInstance.refreshAsync.bind(fetchInstance)),
    run: useMemoizedFn_default(fetchInstance.run.bind(fetchInstance)),
    runAsync: useMemoizedFn_default(fetchInstance.runAsync.bind(fetchInstance)),
    mutate: useMemoizedFn_default(fetchInstance.mutate.bind(fetchInstance))
  };
}
var useRequestImplement_default = useRequestImplement;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/src/useRequest.js
function useRequest(service, options, plugins) {
  return useRequestImplement_default(service, options, [...plugins || [], useDebouncePlugin_default, useLoadingDelayPlugin_default, usePollingPlugin_default, useRefreshOnWindowFocusPlugin_default, useThrottlePlugin_default, useAutoRunPlugin_default, useCachePlugin_default, useRetryPlugin_default]);
}
var useRequest_default = useRequest;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRequest/index.js
var useRequest_default2 = useRequest_default;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/usePagination/index.js
var usePagination = (service, options = {}) => {
  var _a;
  const {
    defaultPageSize = 10,
    defaultCurrent = 1
  } = options, rest = __rest(options, ["defaultPageSize", "defaultCurrent"]);
  const result = useRequest_default2(service, Object.assign({
    defaultParams: [{
      current: defaultCurrent,
      pageSize: defaultPageSize
    }],
    refreshDepsAction: () => {
      changeCurrent(1);
    }
  }, rest));
  const {
    current = 1,
    pageSize = defaultPageSize
  } = result.params[0] || {};
  const total = ((_a = result.data) === null || _a === void 0 ? void 0 : _a.total) || 0;
  const totalPage = (0, import_react17.useMemo)(() => Math.ceil(total / pageSize), [pageSize, total]);
  const onChange = (c, p) => {
    let toCurrent = c <= 0 ? 1 : c;
    const toPageSize = p <= 0 ? 1 : p;
    const tempTotalPage = Math.ceil(total / toPageSize);
    if (toCurrent > tempTotalPage) {
      toCurrent = Math.max(1, tempTotalPage);
    }
    const [oldPaginationParams = {}, ...restParams] = result.params || [];
    result.run(Object.assign(Object.assign({}, oldPaginationParams), {
      current: toCurrent,
      pageSize: toPageSize
    }), ...restParams);
  };
  const changeCurrent = (c) => {
    onChange(c, pageSize);
  };
  const changePageSize = (p) => {
    onChange(current, p);
  };
  return Object.assign(Object.assign({}, result), {
    pagination: {
      current,
      pageSize,
      total,
      totalPage,
      onChange: useMemoizedFn_default(onChange),
      changeCurrent: useMemoizedFn_default(changeCurrent),
      changePageSize: useMemoizedFn_default(changePageSize)
    }
  });
};
var usePagination_default = usePagination;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useAntdTable/index.js
var useAntdTable = (service, options = {}) => {
  var _a;
  const {
    form,
    defaultType = "simple",
    defaultParams,
    manual = false,
    refreshDeps = [],
    ready = true
  } = options, rest = __rest(options, ["form", "defaultType", "defaultParams", "manual", "refreshDeps", "ready"]);
  const result = usePagination_default(service, Object.assign({
    manual: true
  }, rest));
  const {
    params = [],
    run
  } = result;
  const cacheFormTableData = params[2] || {};
  const [type, setType] = (0, import_react18.useState)((cacheFormTableData === null || cacheFormTableData === void 0 ? void 0 : cacheFormTableData.type) || defaultType);
  const allFormDataRef = (0, import_react18.useRef)({});
  const defaultDataSourceRef = (0, import_react18.useRef)([]);
  const isAntdV4 = !!(form === null || form === void 0 ? void 0 : form.getInternalHooks);
  const getActiveFieldValues = () => {
    if (!form) {
      return {};
    }
    if (isAntdV4) {
      return form.getFieldsValue(null, () => true);
    }
    const allFieldsValue = form.getFieldsValue();
    const activeFieldsValue = {};
    Object.keys(allFieldsValue).forEach((key) => {
      if (form.getFieldInstance ? form.getFieldInstance(key) : true) {
        activeFieldsValue[key] = allFieldsValue[key];
      }
    });
    return activeFieldsValue;
  };
  const validateFields = () => {
    if (!form) {
      return Promise.resolve({});
    }
    const activeFieldsValue = getActiveFieldValues();
    const fields = Object.keys(activeFieldsValue);
    if (isAntdV4) {
      return form.validateFields(fields);
    }
    return new Promise((resolve, reject) => {
      form.validateFields(fields, (errors, values) => {
        if (errors) {
          reject(errors);
        } else {
          resolve(values);
        }
      });
    });
  };
  const restoreForm = () => {
    if (!form) {
      return;
    }
    if (isAntdV4) {
      return form.setFieldsValue(allFormDataRef.current);
    }
    const activeFieldsValue = {};
    Object.keys(allFormDataRef.current).forEach((key) => {
      if (form.getFieldInstance ? form.getFieldInstance(key) : true) {
        activeFieldsValue[key] = allFormDataRef.current[key];
      }
    });
    form.setFieldsValue(activeFieldsValue);
  };
  const changeType = () => {
    const activeFieldsValue = getActiveFieldValues();
    allFormDataRef.current = Object.assign(Object.assign({}, allFormDataRef.current), activeFieldsValue);
    setType((t) => t === "simple" ? "advance" : "simple");
  };
  const _submit = (initPagination) => {
    if (!ready) {
      return;
    }
    setTimeout(() => {
      validateFields().then((values = {}) => {
        const pagination = initPagination || Object.assign(Object.assign({
          pageSize: options.defaultPageSize || 10
        }, (params === null || params === void 0 ? void 0 : params[0]) || {}), {
          current: 1
        });
        if (!form) {
          run(pagination);
          return;
        }
        allFormDataRef.current = Object.assign(Object.assign({}, allFormDataRef.current), values);
        run(pagination, values, {
          allFormData: allFormDataRef.current,
          type
        });
      }).catch((err) => err);
    });
  };
  const reset = () => {
    if (form) {
      form.resetFields();
    }
    _submit();
  };
  const submit = (e) => {
    var _a2;
    (_a2 = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _a2 === void 0 ? void 0 : _a2.call(e);
    _submit();
  };
  const onTableChange = (pagination, filters, sorter, extra) => {
    const [oldPaginationParams, ...restParams] = params || [];
    run(Object.assign(Object.assign({}, oldPaginationParams), {
      current: pagination.current,
      pageSize: pagination.pageSize,
      filters,
      sorter,
      extra
    }), ...restParams);
  };
  (0, import_react18.useEffect)(() => {
    if (params.length > 0) {
      allFormDataRef.current = (cacheFormTableData === null || cacheFormTableData === void 0 ? void 0 : cacheFormTableData.allFormData) || {};
      restoreForm();
      run(...params);
      return;
    }
    if (!manual && ready) {
      allFormDataRef.current = (defaultParams === null || defaultParams === void 0 ? void 0 : defaultParams[1]) || {};
      restoreForm();
      _submit(defaultParams === null || defaultParams === void 0 ? void 0 : defaultParams[0]);
    }
  }, []);
  useUpdateEffect_default(() => {
    if (!ready) {
      return;
    }
    restoreForm();
  }, [type]);
  const hasAutoRun = (0, import_react18.useRef)(false);
  hasAutoRun.current = false;
  useUpdateEffect_default(() => {
    if (!manual && ready) {
      hasAutoRun.current = true;
      if (form) {
        form.resetFields();
      }
      allFormDataRef.current = (defaultParams === null || defaultParams === void 0 ? void 0 : defaultParams[1]) || {};
      restoreForm();
      _submit(defaultParams === null || defaultParams === void 0 ? void 0 : defaultParams[0]);
    }
  }, [ready]);
  useUpdateEffect_default(() => {
    if (hasAutoRun.current) {
      return;
    }
    if (!ready) {
      return;
    }
    if (!manual) {
      hasAutoRun.current = true;
      result.pagination.changeCurrent(1);
    }
  }, [...refreshDeps]);
  return Object.assign(Object.assign({}, result), {
    tableProps: {
      dataSource: ((_a = result.data) === null || _a === void 0 ? void 0 : _a.list) || defaultDataSourceRef.current,
      loading: result.loading,
      onChange: useMemoizedFn_default(onTableChange),
      pagination: {
        current: result.pagination.current,
        pageSize: result.pagination.pageSize,
        total: result.pagination.total
      }
    },
    search: {
      submit: useMemoizedFn_default(submit),
      type,
      changeType: useMemoizedFn_default(changeType),
      reset: useMemoizedFn_default(reset)
    }
  });
};
var useAntdTable_default = useAntdTable;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useAsyncEffect/index.js
var import_react19 = __toESM(require_react());
function useAsyncEffect(effect, deps) {
  function isAsyncGenerator(val) {
    return isFunction(val[Symbol.asyncIterator]);
  }
  (0, import_react19.useEffect)(() => {
    const e = effect();
    let cancelled = false;
    function execute() {
      return __awaiter(this, void 0, void 0, function* () {
        if (isAsyncGenerator(e)) {
          while (true) {
            const result = yield e.next();
            if (result.done || cancelled) {
              break;
            }
          }
        } else {
          yield e;
        }
      });
    }
    execute();
    return () => {
      cancelled = true;
    };
  }, deps);
}
var useAsyncEffect_default = useAsyncEffect;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useBoolean/index.js
var import_react21 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useToggle/index.js
var import_react20 = __toESM(require_react());
function useToggle(defaultValue = false, reverseValue) {
  const [state, setState] = (0, import_react20.useState)(defaultValue);
  const actions = (0, import_react20.useMemo)(() => {
    const reverseValueOrigin = reverseValue === void 0 ? !defaultValue : reverseValue;
    const toggle = () => setState((s) => s === defaultValue ? reverseValueOrigin : defaultValue);
    const set = (value) => setState(value);
    const setLeft = () => setState(defaultValue);
    const setRight = () => setState(reverseValueOrigin);
    return {
      toggle,
      set,
      setLeft,
      setRight
    };
  }, []);
  return [state, actions];
}
var useToggle_default = useToggle;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useBoolean/index.js
function useBoolean(defaultValue = false) {
  const [state, {
    toggle,
    set
  }] = useToggle_default(defaultValue);
  const actions = (0, import_react21.useMemo)(() => {
    const setTrue = () => set(true);
    const setFalse = () => set(false);
    return {
      toggle,
      set: (v) => set(!!v),
      setTrue,
      setFalse
    };
  }, []);
  return [state, actions];
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/domTarget.js
function getTargetElement(target, defaultElement) {
  if (!isBrowser_default) {
    return void 0;
  }
  if (!target) {
    return defaultElement;
  }
  let targetElement;
  if (isFunction(target)) {
    targetElement = target();
  } else if ("current" in target) {
    targetElement = target.current;
  } else {
    targetElement = target;
  }
  return targetElement;
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/getDocumentOrShadow.js
var checkIfAllInShadow = (targets) => {
  return targets.every((item) => {
    const targetElement = getTargetElement(item);
    if (!targetElement)
      return false;
    if (targetElement.getRootNode() instanceof ShadowRoot)
      return true;
  });
};
var getShadow = (node) => {
  if (!node) {
    return document;
  }
  return node.getRootNode();
};
var getDocumentOrShadow = (target) => {
  if (!target || !document.getRootNode) {
    return document;
  }
  const targets = Array.isArray(target) ? target : [target];
  if (checkIfAllInShadow(targets)) {
    return getShadow(getTargetElement(targets[0]));
  }
  return document;
};
var getDocumentOrShadow_default = getDocumentOrShadow;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/useEffectWithTarget.js
var import_react23 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/createEffectWithTarget.js
var import_react22 = __toESM(require_react());
var createEffectWithTarget = (useEffectType) => {
  const useEffectWithTarget3 = (effect, deps, target) => {
    const hasInitRef = (0, import_react22.useRef)(false);
    const lastElementRef = (0, import_react22.useRef)([]);
    const lastDepsRef = (0, import_react22.useRef)([]);
    const unLoadRef = (0, import_react22.useRef)();
    useEffectType(() => {
      var _a;
      const targets = Array.isArray(target) ? target : [target];
      const els = targets.map((item) => getTargetElement(item));
      if (!hasInitRef.current) {
        hasInitRef.current = true;
        lastElementRef.current = els;
        lastDepsRef.current = deps;
        unLoadRef.current = effect();
        return;
      }
      if (els.length !== lastElementRef.current.length || !depsAreSame(els, lastElementRef.current) || !depsAreSame(deps, lastDepsRef.current)) {
        (_a = unLoadRef.current) === null || _a === void 0 ? void 0 : _a.call(unLoadRef);
        lastElementRef.current = els;
        lastDepsRef.current = deps;
        unLoadRef.current = effect();
      }
    });
    useUnmount_default(() => {
      var _a;
      (_a = unLoadRef.current) === null || _a === void 0 ? void 0 : _a.call(unLoadRef);
      hasInitRef.current = false;
    });
  };
  return useEffectWithTarget3;
};
var createEffectWithTarget_default = createEffectWithTarget;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/useEffectWithTarget.js
var useEffectWithTarget = createEffectWithTarget_default(import_react23.useEffect);
var useEffectWithTarget_default = useEffectWithTarget;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useClickAway/index.js
function useClickAway(onClickAway, target, eventName = "click") {
  const onClickAwayRef = useLatest_default(onClickAway);
  useEffectWithTarget_default(() => {
    const handler = (event) => {
      const targets = Array.isArray(target) ? target : [target];
      if (targets.some((item) => {
        const targetElement = getTargetElement(item);
        return !targetElement || targetElement.contains(event.target);
      })) {
        return;
      }
      onClickAwayRef.current(event);
    };
    const documentOrShadow = getDocumentOrShadow_default(target);
    const eventNames = Array.isArray(eventName) ? eventName : [eventName];
    eventNames.forEach((event) => documentOrShadow.addEventListener(event, handler));
    return () => {
      eventNames.forEach((event) => documentOrShadow.removeEventListener(event, handler));
    };
  }, Array.isArray(eventName) ? eventName : [eventName], target);
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useControllableValue/index.js
var import_react24 = __toESM(require_react());
function useControllableValue(props = {}, options = {}) {
  const {
    defaultValue,
    defaultValuePropName = "defaultValue",
    valuePropName = "value",
    trigger: trigger2 = "onChange"
  } = options;
  const value = props[valuePropName];
  const isControlled = props.hasOwnProperty(valuePropName);
  const initialValue = (0, import_react24.useMemo)(() => {
    if (isControlled) {
      return value;
    }
    if (props.hasOwnProperty(defaultValuePropName)) {
      return props[defaultValuePropName];
    }
    return defaultValue;
  }, []);
  const stateRef = (0, import_react24.useRef)(initialValue);
  if (isControlled) {
    stateRef.current = value;
  }
  const update = useUpdate_default();
  function setState(v, ...args) {
    const r = isFunction(v) ? v(stateRef.current) : v;
    if (!isControlled) {
      stateRef.current = r;
      update();
    }
    if (props[trigger2]) {
      props[trigger2](r, ...args);
    }
  }
  return [stateRef.current, useMemoizedFn_default(setState)];
}
var useControllableValue_default = useControllableValue;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useCookieState/index.js
var import_js_cookie = __toESM(require_js_cookie());
var import_react25 = __toESM(require_react());
function useCookieState(cookieKey, options = {}) {
  const [state, setState] = (0, import_react25.useState)(() => {
    const cookieValue = import_js_cookie.default.get(cookieKey);
    if (isString(cookieValue))
      return cookieValue;
    if (isFunction(options.defaultValue)) {
      return options.defaultValue();
    }
    return options.defaultValue;
  });
  const updateState = useMemoizedFn_default((newValue, newOptions = {}) => {
    const _a = Object.assign(Object.assign({}, options), newOptions), {
      defaultValue
    } = _a, restOptions = __rest(_a, ["defaultValue"]);
    setState((prevState) => {
      const value = isFunction(newValue) ? newValue(prevState) : newValue;
      if (value === void 0) {
        import_js_cookie.default.remove(cookieKey);
      } else {
        import_js_cookie.default.set(cookieKey, value, restOptions);
      }
      return value;
    });
  });
  return [state, updateState];
}
var useCookieState_default = useCookieState;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useCountDown/index.js
var import_dayjs = __toESM(require_dayjs_min());
var import_react26 = __toESM(require_react());
var calcLeft = (target) => {
  if (!target) {
    return 0;
  }
  const left = (0, import_dayjs.default)(target).valueOf() - Date.now();
  return left < 0 ? 0 : left;
};
var parseMs = (milliseconds) => {
  return {
    days: Math.floor(milliseconds / 864e5),
    hours: Math.floor(milliseconds / 36e5) % 24,
    minutes: Math.floor(milliseconds / 6e4) % 60,
    seconds: Math.floor(milliseconds / 1e3) % 60,
    milliseconds: Math.floor(milliseconds) % 1e3
  };
};
var useCountdown = (options = {}) => {
  const {
    leftTime,
    targetDate,
    interval = 1e3,
    onEnd
  } = options || {};
  const target = (0, import_react26.useMemo)(() => {
    if ("leftTime" in options) {
      return isNumber(leftTime) && leftTime > 0 ? Date.now() + leftTime : void 0;
    } else {
      return targetDate;
    }
  }, [leftTime, targetDate]);
  const [timeLeft, setTimeLeft] = (0, import_react26.useState)(() => calcLeft(target));
  const onEndRef = useLatest_default(onEnd);
  (0, import_react26.useEffect)(() => {
    if (!target) {
      setTimeLeft(0);
      return;
    }
    setTimeLeft(calcLeft(target));
    const timer = setInterval(() => {
      var _a;
      const targetLeft = calcLeft(target);
      setTimeLeft(targetLeft);
      if (targetLeft === 0) {
        clearInterval(timer);
        (_a = onEndRef.current) === null || _a === void 0 ? void 0 : _a.call(onEndRef);
      }
    }, interval);
    return () => clearInterval(timer);
  }, [target, interval]);
  const formattedRes = (0, import_react26.useMemo)(() => parseMs(timeLeft), [timeLeft]);
  return [timeLeft, formattedRes];
};
var useCountDown_default = useCountdown;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useCounter/index.js
var import_react27 = __toESM(require_react());
function getTargetValue(val, options = {}) {
  const {
    min,
    max
  } = options;
  let target = val;
  if (isNumber(max)) {
    target = Math.min(max, target);
  }
  if (isNumber(min)) {
    target = Math.max(min, target);
  }
  return target;
}
function useCounter(initialValue = 0, options = {}) {
  const {
    min,
    max
  } = options;
  const [current, setCurrent] = (0, import_react27.useState)(() => {
    return getTargetValue(initialValue, {
      min,
      max
    });
  });
  const setValue = (value) => {
    setCurrent((c) => {
      const target = isNumber(value) ? value : value(c);
      return getTargetValue(target, {
        max,
        min
      });
    });
  };
  const inc = (delta = 1) => {
    setValue((c) => c + delta);
  };
  const dec = (delta = 1) => {
    setValue((c) => c - delta);
  };
  const set = (value) => {
    setValue(value);
  };
  const reset = () => {
    setValue(initialValue);
  };
  return [current, {
    inc: useMemoizedFn_default(inc),
    dec: useMemoizedFn_default(dec),
    set: useMemoizedFn_default(set),
    reset: useMemoizedFn_default(reset)
  }];
}
var useCounter_default = useCounter;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDebounce/index.js
var import_react29 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDebounceFn/index.js
var import_react28 = __toESM(require_react());
function useDebounceFn(fn, options) {
  var _a;
  if (isDev_default) {
    if (!isFunction(fn)) {
      console.error(`useDebounceFn expected parameter is a function, got ${typeof fn}`);
    }
  }
  const fnRef = useLatest_default(fn);
  const wait = (_a = options === null || options === void 0 ? void 0 : options.wait) !== null && _a !== void 0 ? _a : 1e3;
  const debounced = (0, import_react28.useMemo)(() => debounce_default((...args) => {
    return fnRef.current(...args);
  }, wait, options), []);
  useUnmount_default(() => {
    debounced.cancel();
  });
  return {
    run: debounced,
    cancel: debounced.cancel,
    flush: debounced.flush
  };
}
var useDebounceFn_default = useDebounceFn;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDebounce/index.js
function useDebounce(value, options) {
  const [debounced, setDebounced] = (0, import_react29.useState)(value);
  const {
    run
  } = useDebounceFn_default(() => {
    setDebounced(value);
  }, options);
  (0, import_react29.useEffect)(() => {
    run();
  }, [value]);
  return debounced;
}
var useDebounce_default = useDebounce;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDebounceEffect/index.js
var import_react30 = __toESM(require_react());
function useDebounceEffect(effect, deps, options) {
  const [flag, setFlag] = (0, import_react30.useState)({});
  const {
    run
  } = useDebounceFn_default(() => {
    setFlag({});
  }, options);
  (0, import_react30.useEffect)(() => {
    return run();
  }, deps);
  useUpdateEffect_default(effect, [flag]);
}
var useDebounceEffect_default = useDebounceEffect;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDeepCompareEffect/index.js
var import_react32 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/createDeepCompareEffect/index.js
var import_react31 = __toESM(require_react());
var depsEqual = (aDeps = [], bDeps = []) => {
  return isEqual_default(aDeps, bDeps);
};
var createDeepCompareEffect = (hook) => (effect, deps) => {
  const ref = (0, import_react31.useRef)();
  const signalRef = (0, import_react31.useRef)(0);
  if (deps === void 0 || !depsEqual(deps, ref.current)) {
    ref.current = deps;
    signalRef.current += 1;
  }
  hook(effect, [signalRef.current]);
};

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDeepCompareEffect/index.js
var useDeepCompareEffect_default = createDeepCompareEffect(import_react32.useEffect);

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDeepCompareLayoutEffect/index.js
var import_react33 = __toESM(require_react());
var useDeepCompareLayoutEffect_default = createDeepCompareEffect(import_react33.useLayoutEffect);

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDocumentVisibility/index.js
var import_react34 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useEventListener/index.js
function useEventListener(eventName, handler, options = {}) {
  const handlerRef = useLatest_default(handler);
  useEffectWithTarget_default(() => {
    const targetElement = getTargetElement(options.target, window);
    if (!(targetElement === null || targetElement === void 0 ? void 0 : targetElement.addEventListener)) {
      return;
    }
    const eventListener = (event) => {
      return handlerRef.current(event);
    };
    targetElement.addEventListener(eventName, eventListener, {
      capture: options.capture,
      once: options.once,
      passive: options.passive
    });
    return () => {
      targetElement.removeEventListener(eventName, eventListener, {
        capture: options.capture
      });
    };
  }, [eventName, options.capture, options.once, options.passive], options.target);
}
var useEventListener_default = useEventListener;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDocumentVisibility/index.js
var getVisibility = () => {
  if (!isBrowser_default) {
    return "visible";
  }
  return document.visibilityState;
};
function useDocumentVisibility() {
  const [documentVisibility, setDocumentVisibility] = (0, import_react34.useState)(() => getVisibility());
  useEventListener_default("visibilitychange", () => {
    setDocumentVisibility(getVisibility());
  }, {
    target: () => document
  });
  return documentVisibility;
}
var useDocumentVisibility_default = useDocumentVisibility;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDrag/index.js
var useDrag = (data, target, options = {}) => {
  const optionsRef = useLatest_default(options);
  const dataRef = useLatest_default(data);
  useEffectWithTarget_default(() => {
    const targetElement = getTargetElement(target);
    if (!(targetElement === null || targetElement === void 0 ? void 0 : targetElement.addEventListener)) {
      return;
    }
    const onDragStart = (event) => {
      var _a, _b;
      (_b = (_a = optionsRef.current).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event);
      event.dataTransfer.setData("custom", JSON.stringify(dataRef.current));
    };
    const onDragEnd = (event) => {
      var _a, _b;
      (_b = (_a = optionsRef.current).onDragEnd) === null || _b === void 0 ? void 0 : _b.call(_a, event);
    };
    targetElement.setAttribute("draggable", "true");
    targetElement.addEventListener("dragstart", onDragStart);
    targetElement.addEventListener("dragend", onDragEnd);
    return () => {
      targetElement.removeEventListener("dragstart", onDragStart);
      targetElement.removeEventListener("dragend", onDragEnd);
    };
  }, [], target);
};
var useDrag_default = useDrag;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDrop/index.js
var import_react35 = __toESM(require_react());
var useDrop = (target, options = {}) => {
  const optionsRef = useLatest_default(options);
  const dragEnterTarget = (0, import_react35.useRef)();
  useEffectWithTarget_default(() => {
    const targetElement = getTargetElement(target);
    if (!(targetElement === null || targetElement === void 0 ? void 0 : targetElement.addEventListener)) {
      return;
    }
    const onData = (dataTransfer, event) => {
      const uri = dataTransfer.getData("text/uri-list");
      const dom = dataTransfer.getData("custom");
      if (dom && optionsRef.current.onDom) {
        let data = dom;
        try {
          data = JSON.parse(dom);
        } catch (e) {
          data = dom;
        }
        optionsRef.current.onDom(data, event);
        return;
      }
      if (uri && optionsRef.current.onUri) {
        optionsRef.current.onUri(uri, event);
        return;
      }
      if (dataTransfer.files && dataTransfer.files.length && optionsRef.current.onFiles) {
        optionsRef.current.onFiles(Array.from(dataTransfer.files), event);
        return;
      }
      if (dataTransfer.items && dataTransfer.items.length && optionsRef.current.onText) {
        dataTransfer.items[0].getAsString((text) => {
          optionsRef.current.onText(text, event);
        });
      }
    };
    const onDragEnter = (event) => {
      var _a, _b;
      event.preventDefault();
      event.stopPropagation();
      dragEnterTarget.current = event.target;
      (_b = (_a = optionsRef.current).onDragEnter) === null || _b === void 0 ? void 0 : _b.call(_a, event);
    };
    const onDragOver = (event) => {
      var _a, _b;
      event.preventDefault();
      (_b = (_a = optionsRef.current).onDragOver) === null || _b === void 0 ? void 0 : _b.call(_a, event);
    };
    const onDragLeave = (event) => {
      var _a, _b;
      if (event.target === dragEnterTarget.current) {
        (_b = (_a = optionsRef.current).onDragLeave) === null || _b === void 0 ? void 0 : _b.call(_a, event);
      }
    };
    const onDrop = (event) => {
      var _a, _b;
      event.preventDefault();
      onData(event.dataTransfer, event);
      (_b = (_a = optionsRef.current).onDrop) === null || _b === void 0 ? void 0 : _b.call(_a, event);
    };
    const onPaste = (event) => {
      var _a, _b;
      onData(event.clipboardData, event);
      (_b = (_a = optionsRef.current).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, event);
    };
    targetElement.addEventListener("dragenter", onDragEnter);
    targetElement.addEventListener("dragover", onDragOver);
    targetElement.addEventListener("dragleave", onDragLeave);
    targetElement.addEventListener("drop", onDrop);
    targetElement.addEventListener("paste", onPaste);
    return () => {
      targetElement.removeEventListener("dragenter", onDragEnter);
      targetElement.removeEventListener("dragover", onDragOver);
      targetElement.removeEventListener("dragleave", onDragLeave);
      targetElement.removeEventListener("drop", onDrop);
      targetElement.removeEventListener("paste", onPaste);
    };
  }, [], target);
};
var useDrop_default = useDrop;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useDynamicList/index.js
var import_react36 = __toESM(require_react());
var useDynamicList = (initialList = []) => {
  const counterRef = (0, import_react36.useRef)(-1);
  const keyList = (0, import_react36.useRef)([]);
  const setKey = (0, import_react36.useCallback)((index) => {
    counterRef.current += 1;
    keyList.current.splice(index, 0, counterRef.current);
  }, []);
  const [list, setList] = (0, import_react36.useState)(() => {
    initialList.forEach((_, index) => {
      setKey(index);
    });
    return initialList;
  });
  const resetList = (0, import_react36.useCallback)((newList) => {
    keyList.current = [];
    setList(() => {
      newList.forEach((_, index) => {
        setKey(index);
      });
      return newList;
    });
  }, []);
  const insert = (0, import_react36.useCallback)((index, item) => {
    setList((l) => {
      const temp = [...l];
      temp.splice(index, 0, item);
      setKey(index);
      return temp;
    });
  }, []);
  const getKey = (0, import_react36.useCallback)((index) => keyList.current[index], []);
  const getIndex = (0, import_react36.useCallback)((key) => keyList.current.findIndex((ele) => ele === key), []);
  const merge = (0, import_react36.useCallback)((index, items) => {
    setList((l) => {
      const temp = [...l];
      items.forEach((_, i) => {
        setKey(index + i);
      });
      temp.splice(index, 0, ...items);
      return temp;
    });
  }, []);
  const replace = (0, import_react36.useCallback)((index, item) => {
    setList((l) => {
      const temp = [...l];
      temp[index] = item;
      return temp;
    });
  }, []);
  const remove = (0, import_react36.useCallback)((index) => {
    setList((l) => {
      const temp = [...l];
      temp.splice(index, 1);
      try {
        keyList.current.splice(index, 1);
      } catch (e) {
        console.error(e);
      }
      return temp;
    });
  }, []);
  const move = (0, import_react36.useCallback)((oldIndex, newIndex) => {
    if (oldIndex === newIndex) {
      return;
    }
    setList((l) => {
      const newList = [...l];
      const temp = newList.filter((_, index) => index !== oldIndex);
      temp.splice(newIndex, 0, newList[oldIndex]);
      try {
        const keyTemp = keyList.current.filter((_, index) => index !== oldIndex);
        keyTemp.splice(newIndex, 0, keyList.current[oldIndex]);
        keyList.current = keyTemp;
      } catch (e) {
        console.error(e);
      }
      return temp;
    });
  }, []);
  const push = (0, import_react36.useCallback)((item) => {
    setList((l) => {
      setKey(l.length);
      return l.concat([item]);
    });
  }, []);
  const pop = (0, import_react36.useCallback)(() => {
    try {
      keyList.current = keyList.current.slice(0, keyList.current.length - 1);
    } catch (e) {
      console.error(e);
    }
    setList((l) => l.slice(0, l.length - 1));
  }, []);
  const unshift = (0, import_react36.useCallback)((item) => {
    setList((l) => {
      setKey(0);
      return [item].concat(l);
    });
  }, []);
  const shift = (0, import_react36.useCallback)(() => {
    try {
      keyList.current = keyList.current.slice(1, keyList.current.length);
    } catch (e) {
      console.error(e);
    }
    setList((l) => l.slice(1, l.length));
  }, []);
  const sortList = (0, import_react36.useCallback)(
    (result) => result.map((item, index) => ({
      key: index,
      item
    })).sort((a, b) => getIndex(a.key) - getIndex(b.key)).filter((item) => !!item.item).map((item) => item.item),
    // retrive the data
    []
  );
  return {
    list,
    insert,
    merge,
    replace,
    remove,
    getKey,
    getIndex,
    move,
    push,
    pop,
    unshift,
    shift,
    sortList,
    resetList
  };
};
var useDynamicList_default = useDynamicList;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useEventEmitter/index.js
var import_react37 = __toESM(require_react());
var EventEmitter = class {
  constructor() {
    this.subscriptions = /* @__PURE__ */ new Set();
    this.emit = (val) => {
      for (const subscription of this.subscriptions) {
        subscription(val);
      }
    };
    this.useSubscription = (callback) => {
      const callbackRef = (0, import_react37.useRef)();
      callbackRef.current = callback;
      (0, import_react37.useEffect)(() => {
        function subscription(val) {
          if (callbackRef.current) {
            callbackRef.current(val);
          }
        }
        this.subscriptions.add(subscription);
        return () => {
          this.subscriptions.delete(subscription);
        };
      }, []);
    };
  }
};
function useEventEmitter() {
  const ref = (0, import_react37.useRef)();
  if (!ref.current) {
    ref.current = new EventEmitter();
  }
  return ref.current;
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useEventTarget/index.js
var import_react38 = __toESM(require_react());
function useEventTarget(options) {
  const {
    initialValue,
    transformer
  } = options || {};
  const [value, setValue] = (0, import_react38.useState)(initialValue);
  const transformerRef = useLatest_default(transformer);
  const reset = (0, import_react38.useCallback)(() => setValue(initialValue), []);
  const onChange = (0, import_react38.useCallback)((e) => {
    const _value = e.target.value;
    if (isFunction(transformerRef.current)) {
      return setValue(transformerRef.current(_value));
    }
    return setValue(_value);
  }, []);
  return [value, {
    onChange,
    reset
  }];
}
var useEventTarget_default = useEventTarget;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useExternal/index.js
var import_react39 = __toESM(require_react());
var EXTERNAL_USED_COUNT = {};
var loadScript = (path, props = {}) => {
  const script = document.querySelector(`script[src="${path}"]`);
  if (!script) {
    const newScript = document.createElement("script");
    newScript.src = path;
    Object.keys(props).forEach((key) => {
      newScript[key] = props[key];
    });
    newScript.setAttribute("data-status", "loading");
    document.body.appendChild(newScript);
    return {
      ref: newScript,
      status: "loading"
    };
  }
  return {
    ref: script,
    status: script.getAttribute("data-status") || "ready"
  };
};
var loadCss = (path, props = {}) => {
  const css = document.querySelector(`link[href="${path}"]`);
  if (!css) {
    const newCss = document.createElement("link");
    newCss.rel = "stylesheet";
    newCss.href = path;
    Object.keys(props).forEach((key) => {
      newCss[key] = props[key];
    });
    const isLegacyIECss = "hideFocus" in newCss;
    if (isLegacyIECss && newCss.relList) {
      newCss.rel = "preload";
      newCss.as = "style";
    }
    newCss.setAttribute("data-status", "loading");
    document.head.appendChild(newCss);
    return {
      ref: newCss,
      status: "loading"
    };
  }
  return {
    ref: css,
    status: css.getAttribute("data-status") || "ready"
  };
};
var useExternal = (path, options) => {
  const [status, setStatus] = (0, import_react39.useState)(path ? "loading" : "unset");
  const ref = (0, import_react39.useRef)();
  (0, import_react39.useEffect)(() => {
    if (!path) {
      setStatus("unset");
      return;
    }
    const pathname = path.replace(/[|#].*$/, "");
    if ((options === null || options === void 0 ? void 0 : options.type) === "css" || !(options === null || options === void 0 ? void 0 : options.type) && /(^css!|\.css$)/.test(pathname)) {
      const result = loadCss(path, options === null || options === void 0 ? void 0 : options.css);
      ref.current = result.ref;
      setStatus(result.status);
    } else if ((options === null || options === void 0 ? void 0 : options.type) === "js" || !(options === null || options === void 0 ? void 0 : options.type) && /(^js!|\.js$)/.test(pathname)) {
      const result = loadScript(path, options === null || options === void 0 ? void 0 : options.js);
      ref.current = result.ref;
      setStatus(result.status);
    } else {
      console.error("Cannot infer the type of external resource, and please provide a type ('js' | 'css'). Refer to the https://ahooks.js.org/hooks/dom/use-external/#options");
    }
    if (!ref.current) {
      return;
    }
    if (EXTERNAL_USED_COUNT[path] === void 0) {
      EXTERNAL_USED_COUNT[path] = 1;
    } else {
      EXTERNAL_USED_COUNT[path] += 1;
    }
    const handler = (event) => {
      var _a;
      const targetStatus = event.type === "load" ? "ready" : "error";
      (_a = ref.current) === null || _a === void 0 ? void 0 : _a.setAttribute("data-status", targetStatus);
      setStatus(targetStatus);
    };
    ref.current.addEventListener("load", handler);
    ref.current.addEventListener("error", handler);
    return () => {
      var _a, _b, _c;
      (_a = ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener("load", handler);
      (_b = ref.current) === null || _b === void 0 ? void 0 : _b.removeEventListener("error", handler);
      EXTERNAL_USED_COUNT[path] -= 1;
      if (EXTERNAL_USED_COUNT[path] === 0) {
        (_c = ref.current) === null || _c === void 0 ? void 0 : _c.remove();
      }
      ref.current = void 0;
    };
  }, [path]);
  return status;
};
var useExternal_default = useExternal;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useFavicon/index.js
var import_react40 = __toESM(require_react());
var ImgTypeMap = {
  SVG: "image/svg+xml",
  ICO: "image/x-icon",
  GIF: "image/gif",
  PNG: "image/png"
};
var useFavicon = (href) => {
  (0, import_react40.useEffect)(() => {
    if (!href)
      return;
    const cutUrl = href.split(".");
    const imgSuffix = cutUrl[cutUrl.length - 1].toLocaleUpperCase();
    const link = document.querySelector("link[rel*='icon']") || document.createElement("link");
    link.type = ImgTypeMap[imgSuffix];
    link.href = href;
    link.rel = "shortcut icon";
    document.getElementsByTagName("head")[0].appendChild(link);
  }, [href]);
};
var useFavicon_default = useFavicon;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useFocusWithin/index.js
var import_react41 = __toESM(require_react());
function useFocusWithin(target, options) {
  const [isFocusWithin, setIsFocusWithin] = (0, import_react41.useState)(false);
  const {
    onFocus,
    onBlur,
    onChange
  } = options || {};
  useEventListener_default("focusin", (e) => {
    if (!isFocusWithin) {
      onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
      onChange === null || onChange === void 0 ? void 0 : onChange(true);
      setIsFocusWithin(true);
    }
  }, {
    target
  });
  useEventListener_default("focusout", (e) => {
    var _a, _b;
    if (isFocusWithin && !((_b = (_a = e.currentTarget) === null || _a === void 0 ? void 0 : _a.contains) === null || _b === void 0 ? void 0 : _b.call(_a, e.relatedTarget))) {
      onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
      onChange === null || onChange === void 0 ? void 0 : onChange(false);
      setIsFocusWithin(false);
    }
  }, {
    target
  });
  return isFocusWithin;
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useFullscreen/index.js
var import_react42 = __toESM(require_react());
var import_screenfull = __toESM(require_screenfull());
var useFullscreen = (target, options) => {
  const {
    onExit,
    onEnter
  } = options || {};
  const onExitRef = useLatest_default(onExit);
  const onEnterRef = useLatest_default(onEnter);
  const [state, setState] = (0, import_react42.useState)(false);
  const onChange = () => {
    var _a, _b, _c;
    if (import_screenfull.default.isEnabled) {
      const el = getTargetElement(target);
      if (!import_screenfull.default.element) {
        (_a = onExitRef.current) === null || _a === void 0 ? void 0 : _a.call(onExitRef);
        setState(false);
        import_screenfull.default.off("change", onChange);
      } else {
        const isFullscreen = import_screenfull.default.element === el;
        if (isFullscreen) {
          (_b = onEnterRef.current) === null || _b === void 0 ? void 0 : _b.call(onEnterRef);
        } else {
          (_c = onExitRef.current) === null || _c === void 0 ? void 0 : _c.call(onExitRef);
        }
        setState(isFullscreen);
      }
    }
  };
  const enterFullscreen = () => {
    const el = getTargetElement(target);
    if (!el) {
      return;
    }
    if (import_screenfull.default.isEnabled) {
      try {
        import_screenfull.default.request(el);
        import_screenfull.default.on("change", onChange);
      } catch (error) {
        console.error(error);
      }
    }
  };
  const exitFullscreen = () => {
    const el = getTargetElement(target);
    if (import_screenfull.default.isEnabled && import_screenfull.default.element === el) {
      import_screenfull.default.exit();
    }
  };
  const toggleFullscreen = () => {
    if (state) {
      exitFullscreen();
    } else {
      enterFullscreen();
    }
  };
  useUnmount_default(() => {
    if (import_screenfull.default.isEnabled) {
      import_screenfull.default.off("change", onChange);
    }
  });
  return [state, {
    enterFullscreen: useMemoizedFn_default(enterFullscreen),
    exitFullscreen: useMemoizedFn_default(exitFullscreen),
    toggleFullscreen: useMemoizedFn_default(toggleFullscreen),
    isEnabled: import_screenfull.default.isEnabled
  }];
};
var useFullscreen_default = useFullscreen;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useFusionTable/fusionAdapter.js
var fieldAdapter = (field) => ({
  getFieldInstance: (name) => field.getNames().includes(name),
  setFieldsValue: field.setValues,
  getFieldsValue: field.getValues,
  resetFields: field.resetToDefault,
  validateFields: (fields, callback) => {
    field.validate(fields, callback);
  }
});
var resultAdapter = (result) => {
  const tableProps = {
    dataSource: result.tableProps.dataSource,
    loading: result.tableProps.loading,
    onSort: (dataIndex, order) => {
      var _a;
      result.tableProps.onChange({
        current: result.pagination.current,
        pageSize: result.pagination.pageSize
      }, (_a = result.params[0]) === null || _a === void 0 ? void 0 : _a.filters, {
        field: dataIndex,
        order
      });
    },
    onFilter: (filterParams) => {
      var _a;
      result.tableProps.onChange({
        current: result.pagination.current,
        pageSize: result.pagination.pageSize
      }, filterParams, (_a = result.params[0]) === null || _a === void 0 ? void 0 : _a.sorter);
    }
  };
  const paginationProps = {
    onChange: result.pagination.changeCurrent,
    onPageSizeChange: result.pagination.changePageSize,
    current: result.pagination.current,
    pageSize: result.pagination.pageSize,
    total: result.pagination.total
  };
  return Object.assign(Object.assign({}, result), {
    tableProps,
    paginationProps
  });
};

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useFusionTable/index.js
var useFusionTable = (service, options = {}) => {
  const ret = useAntdTable_default(service, Object.assign(Object.assign({}, options), {
    form: options.field ? fieldAdapter(options.field) : void 0
  }));
  return resultAdapter(ret);
};
var useFusionTable_default = useFusionTable;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useGetState/index.js
var import_react43 = __toESM(require_react());
function useGetState(initialState) {
  const [state, setState] = (0, import_react43.useState)(initialState);
  const stateRef = (0, import_react43.useRef)(state);
  stateRef.current = state;
  const getState = (0, import_react43.useCallback)(() => stateRef.current, []);
  return [state, setState, getState];
}
var useGetState_default = useGetState;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useHistoryTravel/index.js
var import_react44 = __toESM(require_react());
var dumpIndex = (step, arr) => {
  let index = step > 0 ? step - 1 : arr.length + step;
  if (index >= arr.length - 1) {
    index = arr.length - 1;
  }
  if (index < 0) {
    index = 0;
  }
  return index;
};
var split = (step, targetArr) => {
  const index = dumpIndex(step, targetArr);
  return {
    _current: targetArr[index],
    _before: targetArr.slice(0, index),
    _after: targetArr.slice(index + 1)
  };
};
function useHistoryTravel(initialValue, maxLength = 0) {
  const [history, setHistory] = (0, import_react44.useState)({
    present: initialValue,
    past: [],
    future: []
  });
  const {
    present,
    past,
    future
  } = history;
  const initialValueRef = (0, import_react44.useRef)(initialValue);
  const reset = (...params) => {
    const _initial = params.length > 0 ? params[0] : initialValueRef.current;
    initialValueRef.current = _initial;
    setHistory({
      present: _initial,
      future: [],
      past: []
    });
  };
  const updateValue = (val) => {
    const _past = [...past, present];
    const maxLengthNum = isNumber(maxLength) ? maxLength : Number(maxLength);
    if (maxLengthNum > 0 && _past.length > maxLengthNum) {
      _past.splice(0, 1);
    }
    setHistory({
      present: val,
      future: [],
      past: _past
    });
  };
  const _forward = (step = 1) => {
    if (future.length === 0) {
      return;
    }
    const {
      _before,
      _current,
      _after
    } = split(step, future);
    setHistory({
      past: [...past, present, ..._before],
      present: _current,
      future: _after
    });
  };
  const _backward = (step = -1) => {
    if (past.length === 0) {
      return;
    }
    const {
      _before,
      _current,
      _after
    } = split(step, past);
    setHistory({
      past: _before,
      present: _current,
      future: [..._after, present, ...future]
    });
  };
  const go = (step) => {
    const stepNum = isNumber(step) ? step : Number(step);
    if (stepNum === 0) {
      return;
    }
    if (stepNum > 0) {
      return _forward(stepNum);
    }
    _backward(stepNum);
  };
  return {
    value: present,
    backLength: past.length,
    forwardLength: future.length,
    setValue: useMemoizedFn_default(updateValue),
    go: useMemoizedFn_default(go),
    back: useMemoizedFn_default(() => {
      go(-1);
    }),
    forward: useMemoizedFn_default(() => {
      go(1);
    }),
    reset: useMemoizedFn_default(reset)
  };
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useHover/index.js
var useHover_default = (target, options) => {
  const {
    onEnter,
    onLeave,
    onChange
  } = options || {};
  const [state, {
    setTrue,
    setFalse
  }] = useBoolean(false);
  useEventListener_default("mouseenter", () => {
    onEnter === null || onEnter === void 0 ? void 0 : onEnter();
    setTrue();
    onChange === null || onChange === void 0 ? void 0 : onChange(true);
  }, {
    target
  });
  useEventListener_default("mouseleave", () => {
    onLeave === null || onLeave === void 0 ? void 0 : onLeave();
    setFalse();
    onChange === null || onChange === void 0 ? void 0 : onChange(false);
  }, {
    target
  });
  return state;
};

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useInfiniteScroll/index.js
var import_react45 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/rect.js
var getScrollTop = (el) => {
  if (el === document || el === document.body) {
    return Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);
  }
  return el.scrollTop;
};
var getScrollHeight = (el) => {
  return el.scrollHeight || Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
};
var getClientHeight = (el) => {
  return el.clientHeight || Math.max(document.documentElement.clientHeight, document.body.clientHeight);
};

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useInfiniteScroll/index.js
var useInfiniteScroll = (service, options = {}) => {
  const {
    target,
    isNoMore,
    threshold = 100,
    reloadDeps = [],
    manual,
    onBefore,
    onSuccess,
    onError,
    onFinally
  } = options;
  const [finalData, setFinalData] = (0, import_react45.useState)();
  const [loadingMore, setLoadingMore] = (0, import_react45.useState)(false);
  const noMore = (0, import_react45.useMemo)(() => {
    if (!isNoMore)
      return false;
    return isNoMore(finalData);
  }, [finalData]);
  const {
    loading,
    run,
    runAsync,
    cancel
  } = useRequest_default2((lastData) => __awaiter(void 0, void 0, void 0, function* () {
    const currentData = yield service(lastData);
    if (!lastData) {
      setFinalData(currentData);
    } else {
      setFinalData(Object.assign(Object.assign({}, currentData), {
        // @ts-ignore
        list: [...lastData.list, ...currentData.list]
      }));
    }
    return currentData;
  }), {
    manual,
    onFinally: (_, d, e) => {
      setLoadingMore(false);
      onFinally === null || onFinally === void 0 ? void 0 : onFinally(d, e);
    },
    onBefore: () => onBefore === null || onBefore === void 0 ? void 0 : onBefore(),
    onSuccess: (d) => {
      setTimeout(() => {
        scrollMethod();
      });
      onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(d);
    },
    onError: (e) => onError === null || onError === void 0 ? void 0 : onError(e)
  });
  const loadMore = () => {
    if (noMore)
      return;
    setLoadingMore(true);
    run(finalData);
  };
  const loadMoreAsync = () => {
    if (noMore)
      return Promise.reject();
    setLoadingMore(true);
    return runAsync(finalData);
  };
  const reload = () => run();
  const reloadAsync = () => runAsync();
  const scrollMethod = () => {
    const el = getTargetElement(target);
    if (!el) {
      return;
    }
    const scrollTop = getScrollTop(el);
    const scrollHeight = getScrollHeight(el);
    const clientHeight = getClientHeight(el);
    if (scrollHeight - scrollTop <= clientHeight + threshold) {
      loadMore();
    }
  };
  useEventListener_default("scroll", () => {
    if (loading || loadingMore) {
      return;
    }
    scrollMethod();
  }, {
    target
  });
  useUpdateEffect_default(() => {
    run();
  }, [...reloadDeps]);
  return {
    data: finalData,
    loading: !loadingMore && loading,
    loadingMore,
    noMore,
    loadMore: useMemoizedFn_default(loadMore),
    loadMoreAsync: useMemoizedFn_default(loadMoreAsync),
    reload: useMemoizedFn_default(reload),
    reloadAsync: useMemoizedFn_default(reloadAsync),
    mutate: setFinalData,
    cancel
  };
};
var useInfiniteScroll_default = useInfiniteScroll;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useInterval/index.js
var import_react46 = __toESM(require_react());
function useInterval(fn, delay, options = {}) {
  const {
    immediate
  } = options;
  const fnRef = useLatest_default(fn);
  const timerRef = (0, import_react46.useRef)(null);
  (0, import_react46.useEffect)(() => {
    if (!isNumber(delay) || delay < 0) {
      return;
    }
    if (immediate) {
      fnRef.current();
    }
    timerRef.current = setInterval(() => {
      fnRef.current();
    }, delay);
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, [delay]);
  const clear = (0, import_react46.useCallback)(() => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
    }
  }, []);
  return clear;
}
var useInterval_default = useInterval;

// node_modules/.pnpm/intersection-observer@0.12.2/node_modules/intersection-observer/intersection-observer.js
(function() {
  "use strict";
  if (typeof window !== "object") {
    return;
  }
  if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
    if (!("isIntersecting" in window.IntersectionObserverEntry.prototype)) {
      Object.defineProperty(
        window.IntersectionObserverEntry.prototype,
        "isIntersecting",
        {
          get: function() {
            return this.intersectionRatio > 0;
          }
        }
      );
    }
    return;
  }
  function getFrameElement(doc) {
    try {
      return doc.defaultView && doc.defaultView.frameElement || null;
    } catch (e) {
      return null;
    }
  }
  var document2 = function(startDoc) {
    var doc = startDoc;
    var frame = getFrameElement(doc);
    while (frame) {
      doc = frame.ownerDocument;
      frame = getFrameElement(doc);
    }
    return doc;
  }(window.document);
  var registry = [];
  var crossOriginUpdater = null;
  var crossOriginRect = null;
  function IntersectionObserverEntry(entry) {
    this.time = entry.time;
    this.target = entry.target;
    this.rootBounds = ensureDOMRect(entry.rootBounds);
    this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
    this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
    this.isIntersecting = !!entry.intersectionRect;
    var targetRect = this.boundingClientRect;
    var targetArea = targetRect.width * targetRect.height;
    var intersectionRect = this.intersectionRect;
    var intersectionArea = intersectionRect.width * intersectionRect.height;
    if (targetArea) {
      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
    } else {
      this.intersectionRatio = this.isIntersecting ? 1 : 0;
    }
  }
  function IntersectionObserver2(callback, opt_options) {
    var options = opt_options || {};
    if (typeof callback != "function") {
      throw new Error("callback must be a function");
    }
    if (options.root && options.root.nodeType != 1 && options.root.nodeType != 9) {
      throw new Error("root must be a Document or Element");
    }
    this._checkForIntersections = throttle(
      this._checkForIntersections.bind(this),
      this.THROTTLE_TIMEOUT
    );
    this._callback = callback;
    this._observationTargets = [];
    this._queuedEntries = [];
    this._rootMarginValues = this._parseRootMargin(options.rootMargin);
    this.thresholds = this._initThresholds(options.threshold);
    this.root = options.root || null;
    this.rootMargin = this._rootMarginValues.map(function(margin) {
      return margin.value + margin.unit;
    }).join(" ");
    this._monitoringDocuments = [];
    this._monitoringUnsubscribes = [];
  }
  IntersectionObserver2.prototype.THROTTLE_TIMEOUT = 100;
  IntersectionObserver2.prototype.POLL_INTERVAL = null;
  IntersectionObserver2.prototype.USE_MUTATION_OBSERVER = true;
  IntersectionObserver2._setupCrossOriginUpdater = function() {
    if (!crossOriginUpdater) {
      crossOriginUpdater = function(boundingClientRect, intersectionRect) {
        if (!boundingClientRect || !intersectionRect) {
          crossOriginRect = getEmptyRect();
        } else {
          crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
        }
        registry.forEach(function(observer2) {
          observer2._checkForIntersections();
        });
      };
    }
    return crossOriginUpdater;
  };
  IntersectionObserver2._resetCrossOriginUpdater = function() {
    crossOriginUpdater = null;
    crossOriginRect = null;
  };
  IntersectionObserver2.prototype.observe = function(target) {
    var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
      return item.element == target;
    });
    if (isTargetAlreadyObserved) {
      return;
    }
    if (!(target && target.nodeType == 1)) {
      throw new Error("target must be an Element");
    }
    this._registerInstance();
    this._observationTargets.push({ element: target, entry: null });
    this._monitorIntersections(target.ownerDocument);
    this._checkForIntersections();
  };
  IntersectionObserver2.prototype.unobserve = function(target) {
    this._observationTargets = this._observationTargets.filter(function(item) {
      return item.element != target;
    });
    this._unmonitorIntersections(target.ownerDocument);
    if (this._observationTargets.length == 0) {
      this._unregisterInstance();
    }
  };
  IntersectionObserver2.prototype.disconnect = function() {
    this._observationTargets = [];
    this._unmonitorAllIntersections();
    this._unregisterInstance();
  };
  IntersectionObserver2.prototype.takeRecords = function() {
    var records = this._queuedEntries.slice();
    this._queuedEntries = [];
    return records;
  };
  IntersectionObserver2.prototype._initThresholds = function(opt_threshold) {
    var threshold = opt_threshold || [0];
    if (!Array.isArray(threshold))
      threshold = [threshold];
    return threshold.sort().filter(function(t, i, a) {
      if (typeof t != "number" || isNaN(t) || t < 0 || t > 1) {
        throw new Error("threshold must be a number between 0 and 1 inclusively");
      }
      return t !== a[i - 1];
    });
  };
  IntersectionObserver2.prototype._parseRootMargin = function(opt_rootMargin) {
    var marginString = opt_rootMargin || "0px";
    var margins = marginString.split(/\s+/).map(function(margin) {
      var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
      if (!parts) {
        throw new Error("rootMargin must be specified in pixels or percent");
      }
      return { value: parseFloat(parts[1]), unit: parts[2] };
    });
    margins[1] = margins[1] || margins[0];
    margins[2] = margins[2] || margins[0];
    margins[3] = margins[3] || margins[1];
    return margins;
  };
  IntersectionObserver2.prototype._monitorIntersections = function(doc) {
    var win = doc.defaultView;
    if (!win) {
      return;
    }
    if (this._monitoringDocuments.indexOf(doc) != -1) {
      return;
    }
    var callback = this._checkForIntersections;
    var monitoringInterval = null;
    var domObserver = null;
    if (this.POLL_INTERVAL) {
      monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
    } else {
      addEvent(win, "resize", callback, true);
      addEvent(doc, "scroll", callback, true);
      if (this.USE_MUTATION_OBSERVER && "MutationObserver" in win) {
        domObserver = new win.MutationObserver(callback);
        domObserver.observe(doc, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      }
    }
    this._monitoringDocuments.push(doc);
    this._monitoringUnsubscribes.push(function() {
      var win2 = doc.defaultView;
      if (win2) {
        if (monitoringInterval) {
          win2.clearInterval(monitoringInterval);
        }
        removeEvent(win2, "resize", callback, true);
      }
      removeEvent(doc, "scroll", callback, true);
      if (domObserver) {
        domObserver.disconnect();
      }
    });
    var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
    if (doc != rootDoc) {
      var frame = getFrameElement(doc);
      if (frame) {
        this._monitorIntersections(frame.ownerDocument);
      }
    }
  };
  IntersectionObserver2.prototype._unmonitorIntersections = function(doc) {
    var index = this._monitoringDocuments.indexOf(doc);
    if (index == -1) {
      return;
    }
    var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
    var hasDependentTargets = this._observationTargets.some(function(item) {
      var itemDoc = item.element.ownerDocument;
      if (itemDoc == doc) {
        return true;
      }
      while (itemDoc && itemDoc != rootDoc) {
        var frame2 = getFrameElement(itemDoc);
        itemDoc = frame2 && frame2.ownerDocument;
        if (itemDoc == doc) {
          return true;
        }
      }
      return false;
    });
    if (hasDependentTargets) {
      return;
    }
    var unsubscribe = this._monitoringUnsubscribes[index];
    this._monitoringDocuments.splice(index, 1);
    this._monitoringUnsubscribes.splice(index, 1);
    unsubscribe();
    if (doc != rootDoc) {
      var frame = getFrameElement(doc);
      if (frame) {
        this._unmonitorIntersections(frame.ownerDocument);
      }
    }
  };
  IntersectionObserver2.prototype._unmonitorAllIntersections = function() {
    var unsubscribes = this._monitoringUnsubscribes.slice(0);
    this._monitoringDocuments.length = 0;
    this._monitoringUnsubscribes.length = 0;
    for (var i = 0; i < unsubscribes.length; i++) {
      unsubscribes[i]();
    }
  };
  IntersectionObserver2.prototype._checkForIntersections = function() {
    if (!this.root && crossOriginUpdater && !crossOriginRect) {
      return;
    }
    var rootIsInDom = this._rootIsInDom();
    var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();
    this._observationTargets.forEach(function(item) {
      var target = item.element;
      var targetRect = getBoundingClientRect(target);
      var rootContainsTarget = this._rootContainsTarget(target);
      var oldEntry = item.entry;
      var intersectionRect = rootIsInDom && rootContainsTarget && this._computeTargetAndRootIntersection(target, targetRect, rootRect);
      var rootBounds = null;
      if (!this._rootContainsTarget(target)) {
        rootBounds = getEmptyRect();
      } else if (!crossOriginUpdater || this.root) {
        rootBounds = rootRect;
      }
      var newEntry = item.entry = new IntersectionObserverEntry({
        time: now(),
        target,
        boundingClientRect: targetRect,
        rootBounds,
        intersectionRect
      });
      if (!oldEntry) {
        this._queuedEntries.push(newEntry);
      } else if (rootIsInDom && rootContainsTarget) {
        if (this._hasCrossedThreshold(oldEntry, newEntry)) {
          this._queuedEntries.push(newEntry);
        }
      } else {
        if (oldEntry && oldEntry.isIntersecting) {
          this._queuedEntries.push(newEntry);
        }
      }
    }, this);
    if (this._queuedEntries.length) {
      this._callback(this.takeRecords(), this);
    }
  };
  IntersectionObserver2.prototype._computeTargetAndRootIntersection = function(target, targetRect, rootRect) {
    if (window.getComputedStyle(target).display == "none")
      return;
    var intersectionRect = targetRect;
    var parent = getParentNode(target);
    var atRoot = false;
    while (!atRoot && parent) {
      var parentRect = null;
      var parentComputedStyle = parent.nodeType == 1 ? window.getComputedStyle(parent) : {};
      if (parentComputedStyle.display == "none")
        return null;
      if (parent == this.root || parent.nodeType == /* DOCUMENT */
      9) {
        atRoot = true;
        if (parent == this.root || parent == document2) {
          if (crossOriginUpdater && !this.root) {
            if (!crossOriginRect || crossOriginRect.width == 0 && crossOriginRect.height == 0) {
              parent = null;
              parentRect = null;
              intersectionRect = null;
            } else {
              parentRect = crossOriginRect;
            }
          } else {
            parentRect = rootRect;
          }
        } else {
          var frame = getParentNode(parent);
          var frameRect = frame && getBoundingClientRect(frame);
          var frameIntersect = frame && this._computeTargetAndRootIntersection(frame, frameRect, rootRect);
          if (frameRect && frameIntersect) {
            parent = frame;
            parentRect = convertFromParentRect(frameRect, frameIntersect);
          } else {
            parent = null;
            intersectionRect = null;
          }
        }
      } else {
        var doc = parent.ownerDocument;
        if (parent != doc.body && parent != doc.documentElement && parentComputedStyle.overflow != "visible") {
          parentRect = getBoundingClientRect(parent);
        }
      }
      if (parentRect) {
        intersectionRect = computeRectIntersection(parentRect, intersectionRect);
      }
      if (!intersectionRect)
        break;
      parent = parent && getParentNode(parent);
    }
    return intersectionRect;
  };
  IntersectionObserver2.prototype._getRootRect = function() {
    var rootRect;
    if (this.root && !isDoc(this.root)) {
      rootRect = getBoundingClientRect(this.root);
    } else {
      var doc = isDoc(this.root) ? this.root : document2;
      var html = doc.documentElement;
      var body = doc.body;
      rootRect = {
        top: 0,
        left: 0,
        right: html.clientWidth || body.clientWidth,
        width: html.clientWidth || body.clientWidth,
        bottom: html.clientHeight || body.clientHeight,
        height: html.clientHeight || body.clientHeight
      };
    }
    return this._expandRectByRootMargin(rootRect);
  };
  IntersectionObserver2.prototype._expandRectByRootMargin = function(rect) {
    var margins = this._rootMarginValues.map(function(margin, i) {
      return margin.unit == "px" ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100;
    });
    var newRect = {
      top: rect.top - margins[0],
      right: rect.right + margins[1],
      bottom: rect.bottom + margins[2],
      left: rect.left - margins[3]
    };
    newRect.width = newRect.right - newRect.left;
    newRect.height = newRect.bottom - newRect.top;
    return newRect;
  };
  IntersectionObserver2.prototype._hasCrossedThreshold = function(oldEntry, newEntry) {
    var oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;
    var newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1;
    if (oldRatio === newRatio)
      return;
    for (var i = 0; i < this.thresholds.length; i++) {
      var threshold = this.thresholds[i];
      if (threshold == oldRatio || threshold == newRatio || threshold < oldRatio !== threshold < newRatio) {
        return true;
      }
    }
  };
  IntersectionObserver2.prototype._rootIsInDom = function() {
    return !this.root || containsDeep(document2, this.root);
  };
  IntersectionObserver2.prototype._rootContainsTarget = function(target) {
    var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
    return containsDeep(rootDoc, target) && (!this.root || rootDoc == target.ownerDocument);
  };
  IntersectionObserver2.prototype._registerInstance = function() {
    if (registry.indexOf(this) < 0) {
      registry.push(this);
    }
  };
  IntersectionObserver2.prototype._unregisterInstance = function() {
    var index = registry.indexOf(this);
    if (index != -1)
      registry.splice(index, 1);
  };
  function now() {
    return window.performance && performance.now && performance.now();
  }
  function throttle(fn, timeout) {
    var timer = null;
    return function() {
      if (!timer) {
        timer = setTimeout(function() {
          fn();
          timer = null;
        }, timeout);
      }
    };
  }
  function addEvent(node, event, fn, opt_useCapture) {
    if (typeof node.addEventListener == "function") {
      node.addEventListener(event, fn, opt_useCapture || false);
    } else if (typeof node.attachEvent == "function") {
      node.attachEvent("on" + event, fn);
    }
  }
  function removeEvent(node, event, fn, opt_useCapture) {
    if (typeof node.removeEventListener == "function") {
      node.removeEventListener(event, fn, opt_useCapture || false);
    } else if (typeof node.detachEvent == "function") {
      node.detachEvent("on" + event, fn);
    }
  }
  function computeRectIntersection(rect1, rect2) {
    var top = Math.max(rect1.top, rect2.top);
    var bottom = Math.min(rect1.bottom, rect2.bottom);
    var left = Math.max(rect1.left, rect2.left);
    var right = Math.min(rect1.right, rect2.right);
    var width = right - left;
    var height = bottom - top;
    return width >= 0 && height >= 0 && {
      top,
      bottom,
      left,
      right,
      width,
      height
    } || null;
  }
  function getBoundingClientRect(el) {
    var rect;
    try {
      rect = el.getBoundingClientRect();
    } catch (err) {
    }
    if (!rect)
      return getEmptyRect();
    if (!(rect.width && rect.height)) {
      rect = {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };
    }
    return rect;
  }
  function getEmptyRect() {
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }
  function ensureDOMRect(rect) {
    if (!rect || "x" in rect) {
      return rect;
    }
    return {
      top: rect.top,
      y: rect.top,
      bottom: rect.bottom,
      left: rect.left,
      x: rect.left,
      right: rect.right,
      width: rect.width,
      height: rect.height
    };
  }
  function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
    var top = parentIntersectionRect.top - parentBoundingRect.top;
    var left = parentIntersectionRect.left - parentBoundingRect.left;
    return {
      top,
      left,
      height: parentIntersectionRect.height,
      width: parentIntersectionRect.width,
      bottom: top + parentIntersectionRect.height,
      right: left + parentIntersectionRect.width
    };
  }
  function containsDeep(parent, child) {
    var node = child;
    while (node) {
      if (node == parent)
        return true;
      node = getParentNode(node);
    }
    return false;
  }
  function getParentNode(node) {
    var parent = node.parentNode;
    if (node.nodeType == /* DOCUMENT */
    9 && node != document2) {
      return getFrameElement(node);
    }
    if (parent && parent.assignedSlot) {
      parent = parent.assignedSlot.parentNode;
    }
    if (parent && parent.nodeType == 11 && parent.host) {
      return parent.host;
    }
    return parent;
  }
  function isDoc(node) {
    return node && node.nodeType === 9;
  }
  window.IntersectionObserver = IntersectionObserver2;
  window.IntersectionObserverEntry = IntersectionObserverEntry;
})();

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useInViewport/index.js
var import_react47 = __toESM(require_react());
function useInViewport(target, options) {
  const [state, setState] = (0, import_react47.useState)();
  const [ratio, setRatio] = (0, import_react47.useState)();
  useEffectWithTarget_default(() => {
    const el = getTargetElement(target);
    if (!el) {
      return;
    }
    const observer2 = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        setRatio(entry.intersectionRatio);
        setState(entry.isIntersecting);
      }
    }, Object.assign(Object.assign({}, options), {
      root: getTargetElement(options === null || options === void 0 ? void 0 : options.root)
    }));
    observer2.observe(el);
    return () => {
      observer2.disconnect();
    };
  }, [options === null || options === void 0 ? void 0 : options.rootMargin, options === null || options === void 0 ? void 0 : options.threshold], target);
  return [state, ratio];
}
var useInViewport_default = useInViewport;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useIsomorphicLayoutEffect/index.js
var import_react48 = __toESM(require_react());
var useIsomorphicLayoutEffect = isBrowser_default ? import_react48.useLayoutEffect : import_react48.useEffect;
var useIsomorphicLayoutEffect_default = useIsomorphicLayoutEffect;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/useDeepCompareWithTarget.js
var import_react49 = __toESM(require_react());
var depsEqual2 = (aDeps, bDeps = []) => {
  return isEqual_default(aDeps, bDeps);
};
var useDeepCompareEffectWithTarget = (effect, deps, target) => {
  const ref = (0, import_react49.useRef)();
  const signalRef = (0, import_react49.useRef)(0);
  if (!depsEqual2(deps, ref.current)) {
    ref.current = deps;
    signalRef.current += 1;
  }
  useEffectWithTarget_default(effect, [signalRef.current], target);
};
var useDeepCompareWithTarget_default = useDeepCompareEffectWithTarget;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/isAppleDevice.js
var isAppleDevice = /(mac|iphone|ipod|ipad)/i.test(typeof navigator !== "undefined" ? navigator === null || navigator === void 0 ? void 0 : navigator.platform : "");
var isAppleDevice_default = isAppleDevice;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useKeyPress/index.js
var aliasKeyCodeMap = {
  "0": 48,
  "1": 49,
  "2": 50,
  "3": 51,
  "4": 52,
  "5": 53,
  "6": 54,
  "7": 55,
  "8": 56,
  "9": 57,
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  ctrl: 17,
  alt: 18,
  pausebreak: 19,
  capslock: 20,
  esc: 27,
  space: 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  leftarrow: 37,
  uparrow: 38,
  rightarrow: 39,
  downarrow: 40,
  insert: 45,
  delete: 46,
  a: 65,
  b: 66,
  c: 67,
  d: 68,
  e: 69,
  f: 70,
  g: 71,
  h: 72,
  i: 73,
  j: 74,
  k: 75,
  l: 76,
  m: 77,
  n: 78,
  o: 79,
  p: 80,
  q: 81,
  r: 82,
  s: 83,
  t: 84,
  u: 85,
  v: 86,
  w: 87,
  x: 88,
  y: 89,
  z: 90,
  leftwindowkey: 91,
  rightwindowkey: 92,
  selectkey: 93,
  numpad0: 96,
  numpad1: 97,
  numpad2: 98,
  numpad3: 99,
  numpad4: 100,
  numpad5: 101,
  numpad6: 102,
  numpad7: 103,
  numpad8: 104,
  numpad9: 105,
  multiply: 106,
  add: 107,
  subtract: 109,
  decimalpoint: 110,
  divide: 111,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  numlock: 144,
  scrolllock: 145,
  semicolon: 186,
  equalsign: 187,
  comma: 188,
  dash: 189,
  period: 190,
  forwardslash: 191,
  graveaccent: 192,
  openbracket: 219,
  backslash: 220,
  closebracket: 221,
  singlequote: 222
};
if (isAppleDevice_default) {
  aliasKeyCodeMap["meta"] = [91, 93];
} else {
  aliasKeyCodeMap["meta"] = [91, 92];
}
var modifierKey = {
  ctrl: (event) => event.ctrlKey,
  shift: (event) => event.shiftKey,
  alt: (event) => event.altKey,
  meta: (event) => {
    if (event.type === "keyup") {
      return aliasKeyCodeMap["meta"].includes(event.keyCode);
    }
    return event.metaKey;
  }
};
function countKeyByEvent(event) {
  const countOfModifier = Object.keys(modifierKey).reduce((total, key) => {
    if (modifierKey[key](event)) {
      return total + 1;
    }
    return total;
  }, 0);
  return [16, 17, 18, 91, 92].includes(event.keyCode) ? countOfModifier : countOfModifier + 1;
}
function genFilterKey(event, keyFilter, exactMatch) {
  if (!event.key) {
    return false;
  }
  if (isNumber(keyFilter)) {
    return event.keyCode === keyFilter;
  }
  const genArr = keyFilter.split(".");
  let genLen = 0;
  for (const key of genArr) {
    const genModifier = modifierKey[key];
    const aliasKeyCode = aliasKeyCodeMap[key.toLowerCase()];
    if (genModifier && genModifier(event) || aliasKeyCode && aliasKeyCode === event.keyCode) {
      genLen++;
    }
  }
  if (exactMatch) {
    return genLen === genArr.length && countKeyByEvent(event) === genArr.length;
  }
  return genLen === genArr.length;
}
function genKeyFormatter(keyFilter, exactMatch) {
  if (isFunction(keyFilter)) {
    return keyFilter;
  }
  if (isString(keyFilter) || isNumber(keyFilter)) {
    return (event) => genFilterKey(event, keyFilter, exactMatch);
  }
  if (Array.isArray(keyFilter)) {
    return (event) => keyFilter.some((item) => genFilterKey(event, item, exactMatch));
  }
  return () => Boolean(keyFilter);
}
var defaultEvents = ["keydown"];
function useKeyPress(keyFilter, eventHandler, option) {
  const {
    events = defaultEvents,
    target,
    exactMatch = false,
    useCapture = false
  } = option || {};
  const eventHandlerRef = useLatest_default(eventHandler);
  const keyFilterRef = useLatest_default(keyFilter);
  useDeepCompareWithTarget_default(() => {
    var _a;
    const el = getTargetElement(target, window);
    if (!el) {
      return;
    }
    const callbackHandler = (event) => {
      var _a2;
      const genGuard = genKeyFormatter(keyFilterRef.current, exactMatch);
      if (genGuard(event)) {
        return (_a2 = eventHandlerRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(eventHandlerRef, event);
      }
    };
    for (const eventName of events) {
      (_a = el === null || el === void 0 ? void 0 : el.addEventListener) === null || _a === void 0 ? void 0 : _a.call(el, eventName, callbackHandler, useCapture);
    }
    return () => {
      var _a2;
      for (const eventName of events) {
        (_a2 = el === null || el === void 0 ? void 0 : el.removeEventListener) === null || _a2 === void 0 ? void 0 : _a2.call(el, eventName, callbackHandler, useCapture);
      }
    };
  }, [events], target);
}
var useKeyPress_default = useKeyPress;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/createUseStorageState/index.js
var import_react50 = __toESM(require_react());
function createUseStorageState(getStorage) {
  function useStorageState(key, options) {
    let storage;
    try {
      storage = getStorage();
    } catch (err) {
      console.error(err);
    }
    const serializer = (value) => {
      if (options === null || options === void 0 ? void 0 : options.serializer) {
        return options === null || options === void 0 ? void 0 : options.serializer(value);
      }
      return JSON.stringify(value);
    };
    const deserializer = (value) => {
      if (options === null || options === void 0 ? void 0 : options.deserializer) {
        return options === null || options === void 0 ? void 0 : options.deserializer(value);
      }
      return JSON.parse(value);
    };
    function getStoredValue() {
      try {
        const raw = storage === null || storage === void 0 ? void 0 : storage.getItem(key);
        if (raw) {
          return deserializer(raw);
        }
      } catch (e) {
        console.error(e);
      }
      if (isFunction(options === null || options === void 0 ? void 0 : options.defaultValue)) {
        return options === null || options === void 0 ? void 0 : options.defaultValue();
      }
      return options === null || options === void 0 ? void 0 : options.defaultValue;
    }
    const [state, setState] = (0, import_react50.useState)(() => getStoredValue());
    useUpdateEffect_default(() => {
      setState(getStoredValue());
    }, [key]);
    const updateState = (value) => {
      const currentState = isFunction(value) ? value(state) : value;
      setState(currentState);
      if (isUndef(currentState)) {
        storage === null || storage === void 0 ? void 0 : storage.removeItem(key);
      } else {
        try {
          storage === null || storage === void 0 ? void 0 : storage.setItem(key, serializer(currentState));
        } catch (e) {
          console.error(e);
        }
      }
    };
    return [state, useMemoizedFn_default(updateState)];
  }
  return useStorageState;
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useLocalStorageState/index.js
var useLocalStorageState = createUseStorageState(() => isBrowser_default ? localStorage : void 0);
var useLocalStorageState_default = useLocalStorageState;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useLockFn/index.js
var import_react51 = __toESM(require_react());
function useLockFn(fn) {
  const lockRef = (0, import_react51.useRef)(false);
  return (0, import_react51.useCallback)((...args) => __awaiter(this, void 0, void 0, function* () {
    if (lockRef.current)
      return;
    lockRef.current = true;
    try {
      const ret = yield fn(...args);
      lockRef.current = false;
      return ret;
    } catch (e) {
      lockRef.current = false;
      throw e;
    }
  }), [fn]);
}
var useLockFn_default = useLockFn;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useLongPress/index.js
var import_react52 = __toESM(require_react());
var touchSupported = isBrowser_default && // @ts-ignore
("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch);
function useLongPress(onLongPress, target, {
  delay = 300,
  moveThreshold,
  onClick,
  onLongPressEnd
} = {}) {
  const onLongPressRef = useLatest_default(onLongPress);
  const onClickRef = useLatest_default(onClick);
  const onLongPressEndRef = useLatest_default(onLongPressEnd);
  const timerRef = (0, import_react52.useRef)();
  const isTriggeredRef = (0, import_react52.useRef)(false);
  const pervPositionRef = (0, import_react52.useRef)({
    x: 0,
    y: 0
  });
  const hasMoveThreshold = !!((moveThreshold === null || moveThreshold === void 0 ? void 0 : moveThreshold.x) && moveThreshold.x > 0 || (moveThreshold === null || moveThreshold === void 0 ? void 0 : moveThreshold.y) && moveThreshold.y > 0);
  useEffectWithTarget_default(() => {
    const targetElement = getTargetElement(target);
    if (!(targetElement === null || targetElement === void 0 ? void 0 : targetElement.addEventListener)) {
      return;
    }
    const overThreshold = (event) => {
      const {
        clientX,
        clientY
      } = getClientPosition(event);
      const offsetX = Math.abs(clientX - pervPositionRef.current.x);
      const offsetY = Math.abs(clientY - pervPositionRef.current.y);
      return !!((moveThreshold === null || moveThreshold === void 0 ? void 0 : moveThreshold.x) && offsetX > moveThreshold.x || (moveThreshold === null || moveThreshold === void 0 ? void 0 : moveThreshold.y) && offsetY > moveThreshold.y);
    };
    function getClientPosition(event) {
      if (event instanceof TouchEvent) {
        return {
          clientX: event.touches[0].clientX,
          clientY: event.touches[0].clientY
        };
      }
      if (event instanceof MouseEvent) {
        return {
          clientX: event.clientX,
          clientY: event.clientY
        };
      }
      console.warn("Unsupported event type");
      return {
        clientX: 0,
        clientY: 0
      };
    }
    const onStart = (event) => {
      if (hasMoveThreshold) {
        const {
          clientX,
          clientY
        } = getClientPosition(event);
        pervPositionRef.current.x = clientX;
        pervPositionRef.current.y = clientY;
      }
      timerRef.current = setTimeout(() => {
        onLongPressRef.current(event);
        isTriggeredRef.current = true;
      }, delay);
    };
    const onMove = (event) => {
      if (timerRef.current && overThreshold(event)) {
        clearInterval(timerRef.current);
        timerRef.current = void 0;
      }
    };
    const onEnd = (event, shouldTriggerClick = false) => {
      var _a;
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
      if (isTriggeredRef.current) {
        (_a = onLongPressEndRef.current) === null || _a === void 0 ? void 0 : _a.call(onLongPressEndRef, event);
      }
      if (shouldTriggerClick && !isTriggeredRef.current && onClickRef.current) {
        onClickRef.current(event);
      }
      isTriggeredRef.current = false;
    };
    const onEndWithClick = (event) => onEnd(event, true);
    if (!touchSupported) {
      targetElement.addEventListener("mousedown", onStart);
      targetElement.addEventListener("mouseup", onEndWithClick);
      targetElement.addEventListener("mouseleave", onEnd);
      if (hasMoveThreshold)
        targetElement.addEventListener("mousemove", onMove);
    } else {
      targetElement.addEventListener("touchstart", onStart);
      targetElement.addEventListener("touchend", onEndWithClick);
      if (hasMoveThreshold)
        targetElement.addEventListener("touchmove", onMove);
    }
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
        isTriggeredRef.current = false;
      }
      if (!touchSupported) {
        targetElement.removeEventListener("mousedown", onStart);
        targetElement.removeEventListener("mouseup", onEndWithClick);
        targetElement.removeEventListener("mouseleave", onEnd);
        if (hasMoveThreshold)
          targetElement.removeEventListener("mousemove", onMove);
      } else {
        targetElement.removeEventListener("touchstart", onStart);
        targetElement.removeEventListener("touchend", onEndWithClick);
        if (hasMoveThreshold)
          targetElement.removeEventListener("touchmove", onMove);
      }
    };
  }, [], target);
}
var useLongPress_default = useLongPress;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useMap/index.js
var import_react53 = __toESM(require_react());
function useMap(initialValue) {
  const getInitValue = () => {
    return initialValue === void 0 ? /* @__PURE__ */ new Map() : new Map(initialValue);
  };
  const [map, setMap] = (0, import_react53.useState)(() => getInitValue());
  const set = (key, entry) => {
    setMap((prev) => {
      const temp = new Map(prev);
      temp.set(key, entry);
      return temp;
    });
  };
  const setAll = (newMap) => {
    setMap(new Map(newMap));
  };
  const remove = (key) => {
    setMap((prev) => {
      const temp = new Map(prev);
      temp.delete(key);
      return temp;
    });
  };
  const reset = () => setMap(getInitValue());
  const get = (key) => map.get(key);
  return [map, {
    set: useMemoizedFn_default(set),
    setAll: useMemoizedFn_default(setAll),
    remove: useMemoizedFn_default(remove),
    reset: useMemoizedFn_default(reset),
    get: useMemoizedFn_default(get)
  }];
}
var useMap_default = useMap;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRafState/index.js
var import_react54 = __toESM(require_react());
function useRafState(initialState) {
  const ref = (0, import_react54.useRef)(0);
  const [state, setState] = (0, import_react54.useState)(initialState);
  const setRafState = (0, import_react54.useCallback)((value) => {
    cancelAnimationFrame(ref.current);
    ref.current = requestAnimationFrame(() => {
      setState(value);
    });
  }, []);
  useUnmount_default(() => {
    cancelAnimationFrame(ref.current);
  });
  return [state, setRafState];
}
var useRafState_default = useRafState;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useMouse/index.js
var initState = {
  screenX: NaN,
  screenY: NaN,
  clientX: NaN,
  clientY: NaN,
  pageX: NaN,
  pageY: NaN,
  elementX: NaN,
  elementY: NaN,
  elementH: NaN,
  elementW: NaN,
  elementPosX: NaN,
  elementPosY: NaN
};
var useMouse_default = (target) => {
  const [state, setState] = useRafState_default(initState);
  useEventListener_default("mousemove", (event) => {
    const {
      screenX,
      screenY,
      clientX,
      clientY,
      pageX,
      pageY
    } = event;
    const newState = {
      screenX,
      screenY,
      clientX,
      clientY,
      pageX,
      pageY,
      elementX: NaN,
      elementY: NaN,
      elementH: NaN,
      elementW: NaN,
      elementPosX: NaN,
      elementPosY: NaN
    };
    const targetElement = getTargetElement(target);
    if (targetElement) {
      const {
        left,
        top,
        width,
        height
      } = targetElement.getBoundingClientRect();
      newState.elementPosX = left + window.pageXOffset;
      newState.elementPosY = top + window.pageYOffset;
      newState.elementX = pageX - newState.elementPosX;
      newState.elementY = pageY - newState.elementPosY;
      newState.elementW = width;
      newState.elementH = height;
    }
    setState(newState);
  }, {
    target: () => document
  });
  return state;
};

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useNetwork/index.js
var import_react55 = __toESM(require_react());
var NetworkEventType;
(function(NetworkEventType2) {
  NetworkEventType2["ONLINE"] = "online";
  NetworkEventType2["OFFLINE"] = "offline";
  NetworkEventType2["CHANGE"] = "change";
})(NetworkEventType || (NetworkEventType = {}));
function getConnection() {
  const nav = navigator;
  if (!isObject(nav))
    return null;
  return nav.connection || nav.mozConnection || nav.webkitConnection;
}
function getConnectionProperty() {
  const c = getConnection();
  if (!c)
    return {};
  return {
    rtt: c.rtt,
    type: c.type,
    saveData: c.saveData,
    downlink: c.downlink,
    downlinkMax: c.downlinkMax,
    effectiveType: c.effectiveType
  };
}
function useNetwork() {
  const [state, setState] = (0, import_react55.useState)(() => {
    return Object.assign({
      since: void 0,
      online: navigator === null || navigator === void 0 ? void 0 : navigator.onLine
    }, getConnectionProperty());
  });
  (0, import_react55.useEffect)(() => {
    const onOnline = () => {
      setState((prevState) => Object.assign(Object.assign({}, prevState), {
        online: true,
        since: new Date()
      }));
    };
    const onOffline = () => {
      setState((prevState) => Object.assign(Object.assign({}, prevState), {
        online: false,
        since: new Date()
      }));
    };
    const onConnectionChange = () => {
      setState((prevState) => Object.assign(Object.assign({}, prevState), getConnectionProperty()));
    };
    window.addEventListener(NetworkEventType.ONLINE, onOnline);
    window.addEventListener(NetworkEventType.OFFLINE, onOffline);
    const connection = getConnection();
    connection === null || connection === void 0 ? void 0 : connection.addEventListener(NetworkEventType.CHANGE, onConnectionChange);
    return () => {
      window.removeEventListener(NetworkEventType.ONLINE, onOnline);
      window.removeEventListener(NetworkEventType.OFFLINE, onOffline);
      connection === null || connection === void 0 ? void 0 : connection.removeEventListener(NetworkEventType.CHANGE, onConnectionChange);
    };
  }, []);
  return state;
}
var useNetwork_default = useNetwork;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/usePrevious/index.js
var import_react56 = __toESM(require_react());
var defaultShouldUpdate = (a, b) => !Object.is(a, b);
function usePrevious(state, shouldUpdate = defaultShouldUpdate) {
  const prevRef = (0, import_react56.useRef)();
  const curRef = (0, import_react56.useRef)();
  if (shouldUpdate(curRef.current, state)) {
    prevRef.current = curRef.current;
    curRef.current = state;
  }
  return prevRef.current;
}
var usePrevious_default = usePrevious;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRafInterval/index.js
var import_react57 = __toESM(require_react());
var setRafInterval = function(callback, delay = 0) {
  if (typeof requestAnimationFrame === "undefined") {
    return {
      id: setInterval(callback, delay)
    };
  }
  let start = new Date().getTime();
  const handle = {
    id: 0
  };
  const loop = () => {
    const current = new Date().getTime();
    if (current - start >= delay) {
      callback();
      start = new Date().getTime();
    }
    handle.id = requestAnimationFrame(loop);
  };
  handle.id = requestAnimationFrame(loop);
  return handle;
};
function cancelAnimationFrameIsNotDefined(t) {
  return typeof cancelAnimationFrame === "undefined";
}
var clearRafInterval = function(handle) {
  if (cancelAnimationFrameIsNotDefined(handle.id)) {
    return clearInterval(handle.id);
  }
  cancelAnimationFrame(handle.id);
};
function useRafInterval(fn, delay, options) {
  const immediate = options === null || options === void 0 ? void 0 : options.immediate;
  const fnRef = useLatest_default(fn);
  const timerRef = (0, import_react57.useRef)();
  (0, import_react57.useEffect)(() => {
    if (!isNumber(delay) || delay < 0)
      return;
    if (immediate) {
      fnRef.current();
    }
    timerRef.current = setRafInterval(() => {
      fnRef.current();
    }, delay);
    return () => {
      if (timerRef.current) {
        clearRafInterval(timerRef.current);
      }
    };
  }, [delay]);
  const clear = (0, import_react57.useCallback)(() => {
    if (timerRef.current) {
      clearRafInterval(timerRef.current);
    }
  }, []);
  return clear;
}
var useRafInterval_default = useRafInterval;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useRafTimeout/index.js
var import_react58 = __toESM(require_react());
var setRafTimeout = function(callback, delay = 0) {
  if (typeof requestAnimationFrame === "undefined") {
    return {
      id: setTimeout(callback, delay)
    };
  }
  const handle = {
    id: 0
  };
  const startTime = new Date().getTime();
  const loop = () => {
    const current = new Date().getTime();
    if (current - startTime >= delay) {
      callback();
    } else {
      handle.id = requestAnimationFrame(loop);
    }
  };
  handle.id = requestAnimationFrame(loop);
  return handle;
};
function cancelAnimationFrameIsNotDefined2(t) {
  return typeof cancelAnimationFrame === "undefined";
}
var clearRafTimeout = function(handle) {
  if (cancelAnimationFrameIsNotDefined2(handle.id)) {
    return clearTimeout(handle.id);
  }
  cancelAnimationFrame(handle.id);
};
function useRafTimeout(fn, delay) {
  const fnRef = useLatest_default(fn);
  const timerRef = (0, import_react58.useRef)();
  (0, import_react58.useEffect)(() => {
    if (!isNumber(delay) || delay < 0)
      return;
    timerRef.current = setRafTimeout(() => {
      fnRef.current();
    }, delay);
    return () => {
      if (timerRef.current) {
        clearRafTimeout(timerRef.current);
      }
    };
  }, [delay]);
  const clear = (0, import_react58.useCallback)(() => {
    if (timerRef.current) {
      clearRafTimeout(timerRef.current);
    }
  }, []);
  return clear;
}
var useRafTimeout_default = useRafTimeout;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useReactive/index.js
var import_react59 = __toESM(require_react());
var proxyMap = /* @__PURE__ */ new WeakMap();
var rawMap = /* @__PURE__ */ new WeakMap();
function observer(initialVal, cb) {
  const existingProxy = proxyMap.get(initialVal);
  if (existingProxy) {
    return existingProxy;
  }
  if (rawMap.has(initialVal)) {
    return initialVal;
  }
  const proxy = new Proxy(initialVal, {
    get(target, key, receiver) {
      const res = Reflect.get(target, key, receiver);
      return isObject(res) ? observer(res, cb) : res;
    },
    set(target, key, val) {
      const ret = Reflect.set(target, key, val);
      cb();
      return ret;
    },
    deleteProperty(target, key) {
      const ret = Reflect.deleteProperty(target, key);
      cb();
      return ret;
    }
  });
  proxyMap.set(initialVal, proxy);
  rawMap.set(proxy, initialVal);
  return proxy;
}
function useReactive(initialState) {
  const update = useUpdate_default();
  const stateRef = (0, import_react59.useRef)(initialState);
  const state = useCreation(() => {
    return observer(stateRef.current, () => {
      update();
    });
  }, []);
  return state;
}
var useReactive_default = useReactive;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useResetState/index.js
var import_react60 = __toESM(require_react());
var useResetState = (initialState) => {
  const [state, setState] = (0, import_react60.useState)(initialState);
  const resetState = useMemoizedFn_default(() => {
    setState(initialState);
  });
  return [state, setState, resetState];
};
var useResetState_default = useResetState;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useResponsive/index.js
var import_react61 = __toESM(require_react());
var subscribers = /* @__PURE__ */ new Set();
var info;
var responsiveConfig = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200
};
function handleResize() {
  const oldInfo = info;
  calculate();
  if (oldInfo === info)
    return;
  for (const subscriber of subscribers) {
    subscriber();
  }
}
var listening = false;
function calculate() {
  const width = window.innerWidth;
  const newInfo = {};
  let shouldUpdate = false;
  for (const key of Object.keys(responsiveConfig)) {
    newInfo[key] = width >= responsiveConfig[key];
    if (newInfo[key] !== info[key]) {
      shouldUpdate = true;
    }
  }
  if (shouldUpdate) {
    info = newInfo;
  }
}
function configResponsive(config) {
  responsiveConfig = config;
  if (info)
    calculate();
}
function useResponsive() {
  if (isBrowser_default && !listening) {
    info = {};
    calculate();
    window.addEventListener("resize", handleResize);
    listening = true;
  }
  const [state, setState] = (0, import_react61.useState)(info);
  (0, import_react61.useEffect)(() => {
    if (!isBrowser_default)
      return;
    if (!listening) {
      window.addEventListener("resize", handleResize);
    }
    const subscriber = () => {
      setState(info);
    };
    subscribers.add(subscriber);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        window.removeEventListener("resize", handleResize);
        listening = false;
      }
    };
  }, []);
  return state;
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useSafeState/index.js
var import_react63 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useUnmountedRef/index.js
var import_react62 = __toESM(require_react());
var useUnmountedRef = () => {
  const unmountedRef = (0, import_react62.useRef)(false);
  (0, import_react62.useEffect)(() => {
    unmountedRef.current = false;
    return () => {
      unmountedRef.current = true;
    };
  }, []);
  return unmountedRef;
};
var useUnmountedRef_default = useUnmountedRef;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useSafeState/index.js
function useSafeState(initialState) {
  const unmountedRef = useUnmountedRef_default();
  const [state, setState] = (0, import_react63.useState)(initialState);
  const setCurrentState = (0, import_react63.useCallback)((currentState) => {
    if (unmountedRef.current)
      return;
    setState(currentState);
  }, []);
  return [state, setCurrentState];
}
var useSafeState_default = useSafeState;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useScroll/index.js
function useScroll(target, shouldUpdate = () => true) {
  const [position, setPosition] = useRafState_default();
  const shouldUpdateRef = useLatest_default(shouldUpdate);
  useEffectWithTarget_default(() => {
    const el = getTargetElement(target, document);
    if (!el) {
      return;
    }
    const updatePosition = () => {
      let newPosition;
      if (el === document) {
        if (document.scrollingElement) {
          newPosition = {
            left: document.scrollingElement.scrollLeft,
            top: document.scrollingElement.scrollTop
          };
        } else {
          newPosition = {
            left: Math.max(window.pageXOffset, document.documentElement.scrollLeft, document.body.scrollLeft),
            top: Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop)
          };
        }
      } else {
        newPosition = {
          left: el.scrollLeft,
          top: el.scrollTop
        };
      }
      if (shouldUpdateRef.current(newPosition)) {
        setPosition(newPosition);
      }
    };
    updatePosition();
    el.addEventListener("scroll", updatePosition);
    return () => {
      el.removeEventListener("scroll", updatePosition);
    };
  }, [], target);
  return position;
}
var useScroll_default = useScroll;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useSelections/index.js
var import_react64 = __toESM(require_react());
function useSelections(items, defaultSelected = []) {
  const [selected, setSelected] = (0, import_react64.useState)(defaultSelected);
  const selectedSet = (0, import_react64.useMemo)(() => new Set(selected), [selected]);
  const isSelected = (item) => selectedSet.has(item);
  const select = (item) => {
    selectedSet.add(item);
    return setSelected(Array.from(selectedSet));
  };
  const unSelect = (item) => {
    selectedSet.delete(item);
    return setSelected(Array.from(selectedSet));
  };
  const toggle = (item) => {
    if (isSelected(item)) {
      unSelect(item);
    } else {
      select(item);
    }
  };
  const selectAll = () => {
    items.forEach((o) => {
      selectedSet.add(o);
    });
    setSelected(Array.from(selectedSet));
  };
  const unSelectAll = () => {
    items.forEach((o) => {
      selectedSet.delete(o);
    });
    setSelected(Array.from(selectedSet));
  };
  const noneSelected = (0, import_react64.useMemo)(() => items.every((o) => !selectedSet.has(o)), [items, selectedSet]);
  const allSelected = (0, import_react64.useMemo)(() => items.every((o) => selectedSet.has(o)) && !noneSelected, [items, selectedSet, noneSelected]);
  const partiallySelected = (0, import_react64.useMemo)(() => !noneSelected && !allSelected, [noneSelected, allSelected]);
  const toggleAll = () => allSelected ? unSelectAll() : selectAll();
  return {
    selected,
    noneSelected,
    allSelected,
    partiallySelected,
    setSelected,
    isSelected,
    select: useMemoizedFn_default(select),
    unSelect: useMemoizedFn_default(unSelect),
    toggle: useMemoizedFn_default(toggle),
    selectAll: useMemoizedFn_default(selectAll),
    unSelectAll: useMemoizedFn_default(unSelectAll),
    toggleAll: useMemoizedFn_default(toggleAll)
  };
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useSessionStorageState/index.js
var useSessionStorageState = createUseStorageState(() => isBrowser_default ? sessionStorage : void 0);
var useSessionStorageState_default = useSessionStorageState;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useSet/index.js
var import_react65 = __toESM(require_react());
function useSet(initialValue) {
  const getInitValue = () => {
    return initialValue === void 0 ? /* @__PURE__ */ new Set() : new Set(initialValue);
  };
  const [set, setSet] = (0, import_react65.useState)(() => getInitValue());
  const add = (key) => {
    if (set.has(key)) {
      return;
    }
    setSet((prevSet) => {
      const temp = new Set(prevSet);
      temp.add(key);
      return temp;
    });
  };
  const remove = (key) => {
    if (!set.has(key)) {
      return;
    }
    setSet((prevSet) => {
      const temp = new Set(prevSet);
      temp.delete(key);
      return temp;
    });
  };
  const reset = () => setSet(getInitValue());
  return [set, {
    add: useMemoizedFn_default(add),
    remove: useMemoizedFn_default(remove),
    reset: useMemoizedFn_default(reset)
  }];
}
var useSet_default = useSet;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useSetState/index.js
var import_react66 = __toESM(require_react());
var useSetState = (initialState) => {
  const [state, setState] = (0, import_react66.useState)(initialState);
  const setMergeState = (0, import_react66.useCallback)((patch) => {
    setState((prevState) => {
      const newState = isFunction(patch) ? patch(prevState) : patch;
      return newState ? Object.assign(Object.assign({}, prevState), newState) : prevState;
    });
  }, []);
  return [state, setMergeState];
};
var useSetState_default = useSetState;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/useLayoutEffectWithTarget.js
var import_react67 = __toESM(require_react());
var useEffectWithTarget2 = createEffectWithTarget_default(import_react67.useLayoutEffect);
var useLayoutEffectWithTarget_default = useEffectWithTarget2;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/utils/useIsomorphicLayoutEffectWithTarget.js
var useIsomorphicLayoutEffectWithTarget = isBrowser_default ? useLayoutEffectWithTarget_default : useEffectWithTarget_default;
var useIsomorphicLayoutEffectWithTarget_default = useIsomorphicLayoutEffectWithTarget;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useSize/index.js
function useSize(target) {
  const [state, setState] = useRafState_default();
  useIsomorphicLayoutEffectWithTarget_default(() => {
    const el = getTargetElement(target);
    if (!el) {
      return;
    }
    const resizeObserver = new ResizeObserver_es_default((entries) => {
      entries.forEach((entry) => {
        const {
          clientWidth,
          clientHeight
        } = entry.target;
        setState({
          width: clientWidth,
          height: clientHeight
        });
      });
    });
    resizeObserver.observe(el);
    return () => {
      resizeObserver.disconnect();
    };
  }, [], target);
  return state;
}
var useSize_default = useSize;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useTextSelection/index.js
var import_react68 = __toESM(require_react());
var initRect = {
  top: NaN,
  left: NaN,
  bottom: NaN,
  right: NaN,
  height: NaN,
  width: NaN
};
var initState2 = Object.assign({
  text: ""
}, initRect);
function getRectFromSelection(selection) {
  if (!selection) {
    return initRect;
  }
  if (selection.rangeCount < 1) {
    return initRect;
  }
  const range = selection.getRangeAt(0);
  const {
    height,
    width,
    top,
    left,
    right,
    bottom
  } = range.getBoundingClientRect();
  return {
    height,
    width,
    top,
    left,
    right,
    bottom
  };
}
function useTextSelection(target) {
  const [state, setState] = (0, import_react68.useState)(initState2);
  const stateRef = (0, import_react68.useRef)(state);
  const isInRangeRef = (0, import_react68.useRef)(false);
  stateRef.current = state;
  useEffectWithTarget_default(() => {
    const el = getTargetElement(target, document);
    if (!el) {
      return;
    }
    const mouseupHandler = () => {
      let selObj = null;
      let text = "";
      let rect = initRect;
      if (!window.getSelection)
        return;
      selObj = window.getSelection();
      text = selObj ? selObj.toString() : "";
      if (text && isInRangeRef.current) {
        rect = getRectFromSelection(selObj);
        setState(Object.assign(Object.assign(Object.assign({}, state), {
          text
        }), rect));
      }
    };
    const mousedownHandler = (e) => {
      if (!window.getSelection)
        return;
      if (stateRef.current.text) {
        setState(Object.assign({}, initState2));
      }
      isInRangeRef.current = false;
      const selObj = window.getSelection();
      if (!selObj)
        return;
      selObj.removeAllRanges();
      isInRangeRef.current = el.contains(e.target);
    };
    el.addEventListener("mouseup", mouseupHandler);
    document.addEventListener("mousedown", mousedownHandler);
    return () => {
      el.removeEventListener("mouseup", mouseupHandler);
      document.removeEventListener("mousedown", mousedownHandler);
    };
  }, [], target);
  return state;
}
var useTextSelection_default = useTextSelection;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useThrottle/index.js
var import_react70 = __toESM(require_react());

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useThrottleFn/index.js
var import_react69 = __toESM(require_react());
function useThrottleFn(fn, options) {
  var _a;
  if (isDev_default) {
    if (!isFunction(fn)) {
      console.error(`useThrottleFn expected parameter is a function, got ${typeof fn}`);
    }
  }
  const fnRef = useLatest_default(fn);
  const wait = (_a = options === null || options === void 0 ? void 0 : options.wait) !== null && _a !== void 0 ? _a : 1e3;
  const throttled = (0, import_react69.useMemo)(() => throttle_default((...args) => {
    return fnRef.current(...args);
  }, wait, options), []);
  useUnmount_default(() => {
    throttled.cancel();
  });
  return {
    run: throttled,
    cancel: throttled.cancel,
    flush: throttled.flush
  };
}
var useThrottleFn_default = useThrottleFn;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useThrottle/index.js
function useThrottle(value, options) {
  const [throttled, setThrottled] = (0, import_react70.useState)(value);
  const {
    run
  } = useThrottleFn_default(() => {
    setThrottled(value);
  }, options);
  (0, import_react70.useEffect)(() => {
    run();
  }, [value]);
  return throttled;
}
var useThrottle_default = useThrottle;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useThrottleEffect/index.js
var import_react71 = __toESM(require_react());
function useThrottleEffect(effect, deps, options) {
  const [flag, setFlag] = (0, import_react71.useState)({});
  const {
    run
  } = useThrottleFn_default(() => {
    setFlag({});
  }, options);
  (0, import_react71.useEffect)(() => {
    return run();
  }, deps);
  useUpdateEffect_default(effect, [flag]);
}
var useThrottleEffect_default = useThrottleEffect;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useTimeout/index.js
var import_react72 = __toESM(require_react());
function useTimeout(fn, delay) {
  const fnRef = useLatest_default(fn);
  const timerRef = (0, import_react72.useRef)(null);
  (0, import_react72.useEffect)(() => {
    if (!isNumber(delay) || delay < 0) {
      return;
    }
    timerRef.current = setTimeout(() => {
      fnRef.current();
    }, delay);
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, [delay]);
  const clear = (0, import_react72.useCallback)(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
  }, []);
  return clear;
}
var useTimeout_default = useTimeout;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useTitle/index.js
var import_react73 = __toESM(require_react());
var DEFAULT_OPTIONS = {
  restoreOnUnmount: false
};
function useTitle(title, options = DEFAULT_OPTIONS) {
  const titleRef = (0, import_react73.useRef)(isBrowser_default ? document.title : "");
  (0, import_react73.useEffect)(() => {
    document.title = title;
  }, [title]);
  useUnmount_default(() => {
    if (options.restoreOnUnmount) {
      document.title = titleRef.current;
    }
  });
}
var useTitle_default = useTitle;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useTrackedEffect/index.js
var import_react74 = __toESM(require_react());
var diffTwoDeps = (deps1, deps2) => {
  return deps1 ? deps1.map((_ele, idx) => !Object.is(deps1[idx], deps2 === null || deps2 === void 0 ? void 0 : deps2[idx]) ? idx : -1).filter((ele) => ele >= 0) : deps2 ? deps2.map((_ele, idx) => idx) : [];
};
var useTrackedEffect = (effect, deps) => {
  const previousDepsRef = (0, import_react74.useRef)();
  (0, import_react74.useEffect)(() => {
    const changes = diffTwoDeps(previousDepsRef.current, deps);
    const previousDeps = previousDepsRef.current;
    previousDepsRef.current = deps;
    return effect(changes, previousDeps, deps);
  }, deps);
};
var useTrackedEffect_default = useTrackedEffect;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useUpdateLayoutEffect/index.js
var import_react75 = __toESM(require_react());
var useUpdateLayoutEffect_default = createUpdateEffect(import_react75.useLayoutEffect);

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useVirtualList/index.js
var import_react76 = __toESM(require_react());
var useVirtualList = (list, options) => {
  const {
    containerTarget,
    wrapperTarget,
    itemHeight,
    overscan = 5
  } = options;
  const itemHeightRef = useLatest_default(itemHeight);
  const size = useSize_default(containerTarget);
  const scrollTriggerByScrollToFunc = (0, import_react76.useRef)(false);
  const [targetList, setTargetList] = (0, import_react76.useState)([]);
  const getVisibleCount = (containerHeight, fromIndex) => {
    if (isNumber(itemHeightRef.current)) {
      return Math.ceil(containerHeight / itemHeightRef.current);
    }
    let sum = 0;
    let endIndex = 0;
    for (let i = fromIndex; i < list.length; i++) {
      const height = itemHeightRef.current(i, list[i]);
      sum += height;
      endIndex = i;
      if (sum >= containerHeight) {
        break;
      }
    }
    return endIndex - fromIndex;
  };
  const getOffset = (scrollTop) => {
    if (isNumber(itemHeightRef.current)) {
      return Math.floor(scrollTop / itemHeightRef.current) + 1;
    }
    let sum = 0;
    let offset = 0;
    for (let i = 0; i < list.length; i++) {
      const height = itemHeightRef.current(i, list[i]);
      sum += height;
      if (sum >= scrollTop) {
        offset = i;
        break;
      }
    }
    return offset + 1;
  };
  const getDistanceTop = (index) => {
    if (isNumber(itemHeightRef.current)) {
      const height2 = index * itemHeightRef.current;
      return height2;
    }
    const height = list.slice(0, index).reduce((sum, _, i) => sum + itemHeightRef.current(i, list[i]), 0);
    return height;
  };
  const totalHeight = (0, import_react76.useMemo)(() => {
    if (isNumber(itemHeightRef.current)) {
      return list.length * itemHeightRef.current;
    }
    return list.reduce((sum, _, index) => sum + itemHeightRef.current(index, list[index]), 0);
  }, [list]);
  const calculateRange = () => {
    const container = getTargetElement(containerTarget);
    const wrapper = getTargetElement(wrapperTarget);
    if (container && wrapper) {
      const {
        scrollTop,
        clientHeight
      } = container;
      const offset = getOffset(scrollTop);
      const visibleCount = getVisibleCount(clientHeight, offset);
      const start = Math.max(0, offset - overscan);
      const end = Math.min(list.length, offset + visibleCount + overscan);
      const offsetTop = getDistanceTop(start);
      wrapper.style.height = totalHeight - offsetTop + "px";
      wrapper.style.marginTop = offsetTop + "px";
      setTargetList(list.slice(start, end).map((ele, index) => ({
        data: ele,
        index: index + start
      })));
    }
  };
  (0, import_react76.useEffect)(() => {
    if (!(size === null || size === void 0 ? void 0 : size.width) || !(size === null || size === void 0 ? void 0 : size.height)) {
      return;
    }
    calculateRange();
  }, [size === null || size === void 0 ? void 0 : size.width, size === null || size === void 0 ? void 0 : size.height, list]);
  useEventListener_default("scroll", (e) => {
    if (scrollTriggerByScrollToFunc.current) {
      scrollTriggerByScrollToFunc.current = false;
      return;
    }
    e.preventDefault();
    calculateRange();
  }, {
    target: containerTarget
  });
  const scrollTo = (index) => {
    const container = getTargetElement(containerTarget);
    if (container) {
      scrollTriggerByScrollToFunc.current = true;
      container.scrollTop = getDistanceTop(index);
      calculateRange();
    }
  };
  return [targetList, useMemoizedFn_default(scrollTo)];
};
var useVirtualList_default = useVirtualList;

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useWebSocket/index.js
var import_react77 = __toESM(require_react());
var ReadyState;
(function(ReadyState2) {
  ReadyState2[ReadyState2["Connecting"] = 0] = "Connecting";
  ReadyState2[ReadyState2["Open"] = 1] = "Open";
  ReadyState2[ReadyState2["Closing"] = 2] = "Closing";
  ReadyState2[ReadyState2["Closed"] = 3] = "Closed";
})(ReadyState || (ReadyState = {}));
function useWebSocket(socketUrl, options = {}) {
  const {
    reconnectLimit = 3,
    reconnectInterval = 3 * 1e3,
    manual = false,
    onOpen,
    onClose,
    onMessage,
    onError,
    protocols
  } = options;
  const onOpenRef = useLatest_default(onOpen);
  const onCloseRef = useLatest_default(onClose);
  const onMessageRef = useLatest_default(onMessage);
  const onErrorRef = useLatest_default(onError);
  const reconnectTimesRef = (0, import_react77.useRef)(0);
  const reconnectTimerRef = (0, import_react77.useRef)();
  const websocketRef = (0, import_react77.useRef)();
  const unmountedRef = (0, import_react77.useRef)(false);
  const [latestMessage, setLatestMessage] = (0, import_react77.useState)();
  const [readyState, setReadyState] = (0, import_react77.useState)(ReadyState.Closed);
  const reconnect = () => {
    var _a;
    if (reconnectTimesRef.current < reconnectLimit && ((_a = websocketRef.current) === null || _a === void 0 ? void 0 : _a.readyState) !== ReadyState.Open) {
      if (reconnectTimerRef.current) {
        clearTimeout(reconnectTimerRef.current);
      }
      reconnectTimerRef.current = setTimeout(() => {
        connectWs();
        reconnectTimesRef.current++;
      }, reconnectInterval);
    }
  };
  const connectWs = () => {
    if (reconnectTimerRef.current) {
      clearTimeout(reconnectTimerRef.current);
    }
    if (websocketRef.current) {
      websocketRef.current.close();
    }
    const ws = new WebSocket(socketUrl, protocols);
    setReadyState(ReadyState.Connecting);
    ws.onerror = (event) => {
      var _a;
      if (unmountedRef.current) {
        return;
      }
      reconnect();
      (_a = onErrorRef.current) === null || _a === void 0 ? void 0 : _a.call(onErrorRef, event, ws);
      setReadyState(ws.readyState || ReadyState.Closed);
    };
    ws.onopen = (event) => {
      var _a;
      if (unmountedRef.current) {
        return;
      }
      (_a = onOpenRef.current) === null || _a === void 0 ? void 0 : _a.call(onOpenRef, event, ws);
      reconnectTimesRef.current = 0;
      setReadyState(ws.readyState || ReadyState.Open);
    };
    ws.onmessage = (message) => {
      var _a;
      if (unmountedRef.current) {
        return;
      }
      (_a = onMessageRef.current) === null || _a === void 0 ? void 0 : _a.call(onMessageRef, message, ws);
      setLatestMessage(message);
    };
    ws.onclose = (event) => {
      var _a;
      if (unmountedRef.current) {
        return;
      }
      reconnect();
      (_a = onCloseRef.current) === null || _a === void 0 ? void 0 : _a.call(onCloseRef, event, ws);
      setReadyState(ws.readyState || ReadyState.Closed);
    };
    websocketRef.current = ws;
  };
  const sendMessage = (message) => {
    var _a;
    if (readyState === ReadyState.Open) {
      (_a = websocketRef.current) === null || _a === void 0 ? void 0 : _a.send(message);
    } else {
      throw new Error("WebSocket disconnected");
    }
  };
  const connect = () => {
    reconnectTimesRef.current = 0;
    connectWs();
  };
  const disconnect = () => {
    var _a;
    if (reconnectTimerRef.current) {
      clearTimeout(reconnectTimerRef.current);
    }
    reconnectTimesRef.current = reconnectLimit;
    (_a = websocketRef.current) === null || _a === void 0 ? void 0 : _a.close();
  };
  (0, import_react77.useEffect)(() => {
    if (!manual) {
      connect();
    }
  }, [socketUrl, manual]);
  useUnmount_default(() => {
    unmountedRef.current = true;
    disconnect();
  });
  return {
    latestMessage,
    sendMessage: useMemoizedFn_default(sendMessage),
    connect: useMemoizedFn_default(connect),
    disconnect: useMemoizedFn_default(disconnect),
    readyState,
    webSocketIns: websocketRef.current
  };
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useWhyDidYouUpdate/index.js
var import_react78 = __toESM(require_react());
function useWhyDidYouUpdate(componentName, props) {
  const prevProps = (0, import_react78.useRef)({});
  (0, import_react78.useEffect)(() => {
    if (prevProps.current) {
      const allKeys = Object.keys(Object.assign(Object.assign({}, prevProps.current), props));
      const changedProps = {};
      allKeys.forEach((key) => {
        if (!Object.is(prevProps.current[key], props[key])) {
          changedProps[key] = {
            from: prevProps.current[key],
            to: props[key]
          };
        }
      });
      if (Object.keys(changedProps).length) {
        console.log("[why-did-you-update]", componentName, changedProps);
      }
    }
    prevProps.current = props;
  });
}

// node_modules/.pnpm/ahooks@3.7.4_react@18.2.0/node_modules/ahooks/es/useMutationObserver/index.js
var useMutationObserver = (callback, target, options = {}) => {
  const callbackRef = useLatest_default(callback);
  useDeepCompareWithTarget_default(() => {
    const element = getTargetElement(target);
    if (!element) {
      return;
    }
    const observer2 = new MutationObserver(callbackRef.current);
    observer2.observe(element, options);
    return () => {
      if (observer2) {
        observer2.disconnect();
      }
    };
  }, [options], target);
};
var useMutationObserver_default = useMutationObserver;

export {
  createUpdateEffect,
  useMemoizedFn_default,
  useUpdateEffect_default,
  useCreation,
  useLatest_default,
  useUnmount_default,
  clearCache,
  useMount_default,
  useUpdate_default,
  useRequest_default2 as useRequest_default,
  usePagination_default,
  useAntdTable_default,
  useAsyncEffect_default,
  useToggle_default,
  useBoolean,
  useClickAway,
  useControllableValue_default,
  useCookieState_default,
  useCountDown_default,
  useCounter_default,
  useDebounceFn_default,
  useDebounce_default,
  useDebounceEffect_default,
  useDeepCompareEffect_default,
  useDeepCompareLayoutEffect_default,
  useEventListener_default,
  useDocumentVisibility_default,
  useDrag_default,
  useDrop_default,
  useDynamicList_default,
  useEventEmitter,
  useEventTarget_default,
  useExternal_default,
  useFavicon_default,
  useFocusWithin,
  useFullscreen_default,
  useFusionTable_default,
  useGetState_default,
  useHistoryTravel,
  useHover_default,
  useInfiniteScroll_default,
  useInterval_default,
  useInViewport_default,
  useIsomorphicLayoutEffect_default,
  useKeyPress_default,
  useLocalStorageState_default,
  useLockFn_default,
  useLongPress_default,
  useMap_default,
  useRafState_default,
  useMouse_default,
  useNetwork_default,
  usePrevious_default,
  useRafInterval_default,
  useRafTimeout_default,
  useReactive_default,
  useResetState_default,
  configResponsive,
  useResponsive,
  useUnmountedRef_default,
  useSafeState_default,
  useScroll_default,
  useSelections,
  useSessionStorageState_default,
  useSet_default,
  useSetState_default,
  useSize_default,
  useTextSelection_default,
  useThrottleFn_default,
  useThrottle_default,
  useThrottleEffect_default,
  useTimeout_default,
  useTitle_default,
  useTrackedEffect_default,
  useUpdateLayoutEffect_default,
  useVirtualList_default,
  useWebSocket,
  useWhyDidYouUpdate,
  useMutationObserver_default
};
/*! Bundled license information:

js-cookie/src/js.cookie.js:
  (*!
   * JavaScript Cookie v2.2.1
   * https://github.com/js-cookie/js-cookie
   *
   * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
   * Released under the MIT license
   *)

screenfull/dist/screenfull.js:
  (*!
  * screenfull
  * v5.2.0 - 2021-11-03
  * (c) Sindre Sorhus; MIT License
  *)
*/
//# sourceMappingURL=chunk-KIREWITA.js.map
